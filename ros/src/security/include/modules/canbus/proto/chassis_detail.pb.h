// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/canbus/proto/chassis_detail.proto

#ifndef PROTOBUF_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto__INCLUDED
#define PROTOBUF_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "modules/canbus/proto/chassis.pb.h"
// @@protoc_insertion_point(includes)
namespace apollo {
namespace canbus {
class BasicInfo;
class BasicInfoDefaultTypeInternal;
extern BasicInfoDefaultTypeInternal _BasicInfo_default_instance_;
class Battery;
class BatteryDefaultTypeInternal;
extern BatteryDefaultTypeInternal _Battery_default_instance_;
class Brake;
class BrakeDefaultTypeInternal;
extern BrakeDefaultTypeInternal _Brake_default_instance_;
class Chassis;
class ChassisDefaultTypeInternal;
extern ChassisDefaultTypeInternal _Chassis_default_instance_;
class ChassisDetail;
class ChassisDetailDefaultTypeInternal;
extern ChassisDetailDefaultTypeInternal _ChassisDetail_default_instance_;
class ChassisGPS;
class ChassisGPSDefaultTypeInternal;
extern ChassisGPSDefaultTypeInternal _ChassisGPS_default_instance_;
class CheckResponseSignal;
class CheckResponseSignalDefaultTypeInternal;
extern CheckResponseSignalDefaultTypeInternal _CheckResponseSignal_default_instance_;
class Deceleration;
class DecelerationDefaultTypeInternal;
extern DecelerationDefaultTypeInternal _Deceleration_default_instance_;
class Ems;
class EmsDefaultTypeInternal;
extern EmsDefaultTypeInternal _Ems_default_instance_;
class Epb;
class EpbDefaultTypeInternal;
extern EpbDefaultTypeInternal _Epb_default_instance_;
class Eps;
class EpsDefaultTypeInternal;
extern EpsDefaultTypeInternal _Eps_default_instance_;
class Esp;
class EspDefaultTypeInternal;
extern EspDefaultTypeInternal _Esp_default_instance_;
class Gas;
class GasDefaultTypeInternal;
extern GasDefaultTypeInternal _Gas_default_instance_;
class Gear;
class GearDefaultTypeInternal;
extern GearDefaultTypeInternal _Gear_default_instance_;
class License;
class LicenseDefaultTypeInternal;
extern LicenseDefaultTypeInternal _License_default_instance_;
class Light;
class LightDefaultTypeInternal;
extern LightDefaultTypeInternal _Light_default_instance_;
class Safety;
class SafetyDefaultTypeInternal;
extern SafetyDefaultTypeInternal _Safety_default_instance_;
class VehicleSpd;
class VehicleSpdDefaultTypeInternal;
extern VehicleSpdDefaultTypeInternal _VehicleSpd_default_instance_;
}  // namespace canbus
}  // namespace apollo

namespace apollo {
namespace canbus {

namespace protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto

enum ChassisDetail_Type {
  ChassisDetail_Type_QIRUI_EQ_15 = 0,
  ChassisDetail_Type_CHANGAN_RUICHENG = 1
};
bool ChassisDetail_Type_IsValid(int value);
const ChassisDetail_Type ChassisDetail_Type_Type_MIN = ChassisDetail_Type_QIRUI_EQ_15;
const ChassisDetail_Type ChassisDetail_Type_Type_MAX = ChassisDetail_Type_CHANGAN_RUICHENG;
const int ChassisDetail_Type_Type_ARRAYSIZE = ChassisDetail_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChassisDetail_Type_descriptor();
inline const ::std::string& ChassisDetail_Type_Name(ChassisDetail_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChassisDetail_Type_descriptor(), value);
}
inline bool ChassisDetail_Type_Parse(
    const ::std::string& name, ChassisDetail_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChassisDetail_Type>(
    ChassisDetail_Type_descriptor(), name, value);
}
enum Light_TurnLightType {
  Light_TurnLightType_TURN_LIGHT_OFF = 0,
  Light_TurnLightType_TURN_LEFT_ON = 1,
  Light_TurnLightType_TURN_RIGHT_ON = 2,
  Light_TurnLightType_TURN_LIGHT_ON = 3
};
bool Light_TurnLightType_IsValid(int value);
const Light_TurnLightType Light_TurnLightType_TurnLightType_MIN = Light_TurnLightType_TURN_LIGHT_OFF;
const Light_TurnLightType Light_TurnLightType_TurnLightType_MAX = Light_TurnLightType_TURN_LIGHT_ON;
const int Light_TurnLightType_TurnLightType_ARRAYSIZE = Light_TurnLightType_TurnLightType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Light_TurnLightType_descriptor();
inline const ::std::string& Light_TurnLightType_Name(Light_TurnLightType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Light_TurnLightType_descriptor(), value);
}
inline bool Light_TurnLightType_Parse(
    const ::std::string& name, Light_TurnLightType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Light_TurnLightType>(
    Light_TurnLightType_descriptor(), name, value);
}
enum Light_LampType {
  Light_LampType_BEAM_OFF = 0,
  Light_LampType_HIGH_BEAM_ON = 1,
  Light_LampType_LOW_BEAM_ON = 2
};
bool Light_LampType_IsValid(int value);
const Light_LampType Light_LampType_LampType_MIN = Light_LampType_BEAM_OFF;
const Light_LampType Light_LampType_LampType_MAX = Light_LampType_LOW_BEAM_ON;
const int Light_LampType_LampType_ARRAYSIZE = Light_LampType_LampType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Light_LampType_descriptor();
inline const ::std::string& Light_LampType_Name(Light_LampType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Light_LampType_descriptor(), value);
}
inline bool Light_LampType_Parse(
    const ::std::string& name, Light_LampType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Light_LampType>(
    Light_LampType_descriptor(), name, value);
}
enum Light_LincolnLampType {
  Light_LincolnLampType_BEAM_NULL = 0,
  Light_LincolnLampType_BEAM_FLASH_TO_PASS = 1,
  Light_LincolnLampType_BEAM_HIGH = 2,
  Light_LincolnLampType_BEAM_INVALID = 3
};
bool Light_LincolnLampType_IsValid(int value);
const Light_LincolnLampType Light_LincolnLampType_LincolnLampType_MIN = Light_LincolnLampType_BEAM_NULL;
const Light_LincolnLampType Light_LincolnLampType_LincolnLampType_MAX = Light_LincolnLampType_BEAM_INVALID;
const int Light_LincolnLampType_LincolnLampType_ARRAYSIZE = Light_LincolnLampType_LincolnLampType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Light_LincolnLampType_descriptor();
inline const ::std::string& Light_LincolnLampType_Name(Light_LincolnLampType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Light_LincolnLampType_descriptor(), value);
}
inline bool Light_LincolnLampType_Parse(
    const ::std::string& name, Light_LincolnLampType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Light_LincolnLampType>(
    Light_LincolnLampType_descriptor(), name, value);
}
enum Light_LincolnWiperType {
  Light_LincolnWiperType_WIPER_OFF = 0,
  Light_LincolnWiperType_WIPER_AUTO_OFF = 1,
  Light_LincolnWiperType_WIPER_OFF_MOVING = 2,
  Light_LincolnWiperType_WIPER_MANUAL_OFF = 3,
  Light_LincolnWiperType_WIPER_MANUAL_ON = 4,
  Light_LincolnWiperType_WIPER_MANUAL_LOW = 5,
  Light_LincolnWiperType_WIPER_MANUAL_HIGH = 6,
  Light_LincolnWiperType_WIPER_MIST_FLICK = 7,
  Light_LincolnWiperType_WIPER_WASH = 8,
  Light_LincolnWiperType_WIPER_AUTO_LOW = 9,
  Light_LincolnWiperType_WIPER_AUTO_HIGH = 10,
  Light_LincolnWiperType_WIPER_COURTESY_WIPE = 11,
  Light_LincolnWiperType_WIPER_AUTO_ADJUST = 12,
  Light_LincolnWiperType_WIPER_RESERVED = 13,
  Light_LincolnWiperType_WIPER_STALLED = 14,
  Light_LincolnWiperType_WIPER_NO_DATA = 15
};
bool Light_LincolnWiperType_IsValid(int value);
const Light_LincolnWiperType Light_LincolnWiperType_LincolnWiperType_MIN = Light_LincolnWiperType_WIPER_OFF;
const Light_LincolnWiperType Light_LincolnWiperType_LincolnWiperType_MAX = Light_LincolnWiperType_WIPER_NO_DATA;
const int Light_LincolnWiperType_LincolnWiperType_ARRAYSIZE = Light_LincolnWiperType_LincolnWiperType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Light_LincolnWiperType_descriptor();
inline const ::std::string& Light_LincolnWiperType_Name(Light_LincolnWiperType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Light_LincolnWiperType_descriptor(), value);
}
inline bool Light_LincolnWiperType_Parse(
    const ::std::string& name, Light_LincolnWiperType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Light_LincolnWiperType>(
    Light_LincolnWiperType_descriptor(), name, value);
}
enum Light_LincolnAmbientType {
  Light_LincolnAmbientType_AMBIENT_DARK = 0,
  Light_LincolnAmbientType_AMBIENT_LIGHT = 1,
  Light_LincolnAmbientType_AMBIENT_TWILIGHT = 2,
  Light_LincolnAmbientType_AMBIENT_TUNNEL_ON = 3,
  Light_LincolnAmbientType_AMBIENT_TUNNEL_OFF = 4,
  Light_LincolnAmbientType_AMBIENT_INVALID = 5,
  Light_LincolnAmbientType_AMBIENT_NO_DATA = 7
};
bool Light_LincolnAmbientType_IsValid(int value);
const Light_LincolnAmbientType Light_LincolnAmbientType_LincolnAmbientType_MIN = Light_LincolnAmbientType_AMBIENT_DARK;
const Light_LincolnAmbientType Light_LincolnAmbientType_LincolnAmbientType_MAX = Light_LincolnAmbientType_AMBIENT_NO_DATA;
const int Light_LincolnAmbientType_LincolnAmbientType_ARRAYSIZE = Light_LincolnAmbientType_LincolnAmbientType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Light_LincolnAmbientType_descriptor();
inline const ::std::string& Light_LincolnAmbientType_Name(Light_LincolnAmbientType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Light_LincolnAmbientType_descriptor(), value);
}
inline bool Light_LincolnAmbientType_Parse(
    const ::std::string& name, Light_LincolnAmbientType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Light_LincolnAmbientType>(
    Light_LincolnAmbientType_descriptor(), name, value);
}
enum Eps_Type {
  Eps_Type_NOT_AVAILABLE = 0,
  Eps_Type_READY = 1,
  Eps_Type_ACTIVE = 2,
  Eps_Type_INVALID = 3
};
bool Eps_Type_IsValid(int value);
const Eps_Type Eps_Type_Type_MIN = Eps_Type_NOT_AVAILABLE;
const Eps_Type Eps_Type_Type_MAX = Eps_Type_INVALID;
const int Eps_Type_Type_ARRAYSIZE = Eps_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Eps_Type_descriptor();
inline const ::std::string& Eps_Type_Name(Eps_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Eps_Type_descriptor(), value);
}
inline bool Eps_Type_Parse(
    const ::std::string& name, Eps_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Eps_Type>(
    Eps_Type_descriptor(), name, value);
}
enum VehicleSpd_Type {
  VehicleSpd_Type_FORWARD = 0,
  VehicleSpd_Type_BACKWARD = 1,
  VehicleSpd_Type_STANDSTILL = 2,
  VehicleSpd_Type_INVALID = 3
};
bool VehicleSpd_Type_IsValid(int value);
const VehicleSpd_Type VehicleSpd_Type_Type_MIN = VehicleSpd_Type_FORWARD;
const VehicleSpd_Type VehicleSpd_Type_Type_MAX = VehicleSpd_Type_INVALID;
const int VehicleSpd_Type_Type_ARRAYSIZE = VehicleSpd_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehicleSpd_Type_descriptor();
inline const ::std::string& VehicleSpd_Type_Name(VehicleSpd_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehicleSpd_Type_descriptor(), value);
}
inline bool VehicleSpd_Type_Parse(
    const ::std::string& name, VehicleSpd_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehicleSpd_Type>(
    VehicleSpd_Type_descriptor(), name, value);
}
enum Brake_HSAStatusType {
  Brake_HSAStatusType_HSA_INACTIVE = 0,
  Brake_HSAStatusType_HSA_FINDING_GRADIENT = 1,
  Brake_HSAStatusType_HSA_ACTIVE_PRESSED = 2,
  Brake_HSAStatusType_HSA_ACTIVE_RELEASED = 3,
  Brake_HSAStatusType_HSA_FAST_RELEASE = 4,
  Brake_HSAStatusType_HSA_SLOW_RELEASE = 5,
  Brake_HSAStatusType_HSA_FAILED = 6,
  Brake_HSAStatusType_HSA_UNDEFINED = 7
};
bool Brake_HSAStatusType_IsValid(int value);
const Brake_HSAStatusType Brake_HSAStatusType_HSAStatusType_MIN = Brake_HSAStatusType_HSA_INACTIVE;
const Brake_HSAStatusType Brake_HSAStatusType_HSAStatusType_MAX = Brake_HSAStatusType_HSA_UNDEFINED;
const int Brake_HSAStatusType_HSAStatusType_ARRAYSIZE = Brake_HSAStatusType_HSAStatusType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Brake_HSAStatusType_descriptor();
inline const ::std::string& Brake_HSAStatusType_Name(Brake_HSAStatusType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Brake_HSAStatusType_descriptor(), value);
}
inline bool Brake_HSAStatusType_Parse(
    const ::std::string& name, Brake_HSAStatusType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Brake_HSAStatusType>(
    Brake_HSAStatusType_descriptor(), name, value);
}
enum Brake_HSAModeType {
  Brake_HSAModeType_HSA_OFF = 0,
  Brake_HSAModeType_HSA_AUTO = 1,
  Brake_HSAModeType_HSA_MANUAL = 2,
  Brake_HSAModeType_HSA_MODE_UNDEFINED = 3
};
bool Brake_HSAModeType_IsValid(int value);
const Brake_HSAModeType Brake_HSAModeType_HSAModeType_MIN = Brake_HSAModeType_HSA_OFF;
const Brake_HSAModeType Brake_HSAModeType_HSAModeType_MAX = Brake_HSAModeType_HSA_MODE_UNDEFINED;
const int Brake_HSAModeType_HSAModeType_ARRAYSIZE = Brake_HSAModeType_HSAModeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Brake_HSAModeType_descriptor();
inline const ::std::string& Brake_HSAModeType_Name(Brake_HSAModeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Brake_HSAModeType_descriptor(), value);
}
inline bool Brake_HSAModeType_Parse(
    const ::std::string& name, Brake_HSAModeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Brake_HSAModeType>(
    Brake_HSAModeType_descriptor(), name, value);
}
enum Epb_PBrakeType {
  Epb_PBrakeType_PBRAKE_OFF = 0,
  Epb_PBrakeType_PBRAKE_TRANSITION = 1,
  Epb_PBrakeType_PBRAKE_ON = 2,
  Epb_PBrakeType_PBRAKE_FAULT = 3
};
bool Epb_PBrakeType_IsValid(int value);
const Epb_PBrakeType Epb_PBrakeType_PBrakeType_MIN = Epb_PBrakeType_PBRAKE_OFF;
const Epb_PBrakeType Epb_PBrakeType_PBrakeType_MAX = Epb_PBrakeType_PBRAKE_FAULT;
const int Epb_PBrakeType_PBrakeType_ARRAYSIZE = Epb_PBrakeType_PBrakeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Epb_PBrakeType_descriptor();
inline const ::std::string& Epb_PBrakeType_Name(Epb_PBrakeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Epb_PBrakeType_descriptor(), value);
}
inline bool Epb_PBrakeType_Parse(
    const ::std::string& name, Epb_PBrakeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Epb_PBrakeType>(
    Epb_PBrakeType_descriptor(), name, value);
}
enum Ems_Type {
  Ems_Type_STOP = 0,
  Ems_Type_CRANK = 1,
  Ems_Type_RUNNING = 2,
  Ems_Type_INVALID = 3
};
bool Ems_Type_IsValid(int value);
const Ems_Type Ems_Type_Type_MIN = Ems_Type_STOP;
const Ems_Type Ems_Type_Type_MAX = Ems_Type_INVALID;
const int Ems_Type_Type_ARRAYSIZE = Ems_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Ems_Type_descriptor();
inline const ::std::string& Ems_Type_Name(Ems_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Ems_Type_descriptor(), value);
}
inline bool Ems_Type_Parse(
    const ::std::string& name, Ems_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Ems_Type>(
    Ems_Type_descriptor(), name, value);
}
enum BasicInfo_Type {
  BasicInfo_Type_OFF = 0,
  BasicInfo_Type_ACC = 1,
  BasicInfo_Type_ON = 2,
  BasicInfo_Type_START = 3,
  BasicInfo_Type_INVALID = 4
};
bool BasicInfo_Type_IsValid(int value);
const BasicInfo_Type BasicInfo_Type_Type_MIN = BasicInfo_Type_OFF;
const BasicInfo_Type BasicInfo_Type_Type_MAX = BasicInfo_Type_INVALID;
const int BasicInfo_Type_Type_ARRAYSIZE = BasicInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* BasicInfo_Type_descriptor();
inline const ::std::string& BasicInfo_Type_Name(BasicInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    BasicInfo_Type_descriptor(), value);
}
inline bool BasicInfo_Type_Parse(
    const ::std::string& name, BasicInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BasicInfo_Type>(
    BasicInfo_Type_descriptor(), name, value);
}
// ===================================================================

class ChassisDetail : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.ChassisDetail) */ {
 public:
  ChassisDetail();
  virtual ~ChassisDetail();

  ChassisDetail(const ChassisDetail& from);

  inline ChassisDetail& operator=(const ChassisDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChassisDetail& default_instance();

  static inline const ChassisDetail* internal_default_instance() {
    return reinterpret_cast<const ChassisDetail*>(
               &_ChassisDetail_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ChassisDetail* other);

  // implements Message ----------------------------------------------

  inline ChassisDetail* New() const PROTOBUF_FINAL { return New(NULL); }

  ChassisDetail* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChassisDetail& from);
  void MergeFrom(const ChassisDetail& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChassisDetail* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ChassisDetail_Type Type;
  static const Type QIRUI_EQ_15 =
    ChassisDetail_Type_QIRUI_EQ_15;
  static const Type CHANGAN_RUICHENG =
    ChassisDetail_Type_CHANGAN_RUICHENG;
  static inline bool Type_IsValid(int value) {
    return ChassisDetail_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ChassisDetail_Type_Type_MIN;
  static const Type Type_MAX =
    ChassisDetail_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ChassisDetail_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ChassisDetail_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ChassisDetail_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ChassisDetail_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .apollo.canbus.BasicInfo basic = 2;
  bool has_basic() const;
  void clear_basic();
  static const int kBasicFieldNumber = 2;
  const ::apollo::canbus::BasicInfo& basic() const;
  ::apollo::canbus::BasicInfo* mutable_basic();
  ::apollo::canbus::BasicInfo* release_basic();
  void set_allocated_basic(::apollo::canbus::BasicInfo* basic);

  // optional .apollo.canbus.Safety safety = 3;
  bool has_safety() const;
  void clear_safety();
  static const int kSafetyFieldNumber = 3;
  const ::apollo::canbus::Safety& safety() const;
  ::apollo::canbus::Safety* mutable_safety();
  ::apollo::canbus::Safety* release_safety();
  void set_allocated_safety(::apollo::canbus::Safety* safety);

  // optional .apollo.canbus.Gear gear = 4;
  bool has_gear() const;
  void clear_gear();
  static const int kGearFieldNumber = 4;
  const ::apollo::canbus::Gear& gear() const;
  ::apollo::canbus::Gear* mutable_gear();
  ::apollo::canbus::Gear* release_gear();
  void set_allocated_gear(::apollo::canbus::Gear* gear);

  // optional .apollo.canbus.Ems ems = 5;
  bool has_ems() const;
  void clear_ems();
  static const int kEmsFieldNumber = 5;
  const ::apollo::canbus::Ems& ems() const;
  ::apollo::canbus::Ems* mutable_ems();
  ::apollo::canbus::Ems* release_ems();
  void set_allocated_ems(::apollo::canbus::Ems* ems);

  // optional .apollo.canbus.Esp esp = 6;
  bool has_esp() const;
  void clear_esp();
  static const int kEspFieldNumber = 6;
  const ::apollo::canbus::Esp& esp() const;
  ::apollo::canbus::Esp* mutable_esp();
  ::apollo::canbus::Esp* release_esp();
  void set_allocated_esp(::apollo::canbus::Esp* esp);

  // optional .apollo.canbus.Gas gas = 7;
  bool has_gas() const;
  void clear_gas();
  static const int kGasFieldNumber = 7;
  const ::apollo::canbus::Gas& gas() const;
  ::apollo::canbus::Gas* mutable_gas();
  ::apollo::canbus::Gas* release_gas();
  void set_allocated_gas(::apollo::canbus::Gas* gas);

  // optional .apollo.canbus.Epb epb = 8;
  bool has_epb() const;
  void clear_epb();
  static const int kEpbFieldNumber = 8;
  const ::apollo::canbus::Epb& epb() const;
  ::apollo::canbus::Epb* mutable_epb();
  ::apollo::canbus::Epb* release_epb();
  void set_allocated_epb(::apollo::canbus::Epb* epb);

  // optional .apollo.canbus.Brake brake = 9;
  bool has_brake() const;
  void clear_brake();
  static const int kBrakeFieldNumber = 9;
  const ::apollo::canbus::Brake& brake() const;
  ::apollo::canbus::Brake* mutable_brake();
  ::apollo::canbus::Brake* release_brake();
  void set_allocated_brake(::apollo::canbus::Brake* brake);

  // optional .apollo.canbus.Deceleration deceleration = 10;
  bool has_deceleration() const;
  void clear_deceleration();
  static const int kDecelerationFieldNumber = 10;
  const ::apollo::canbus::Deceleration& deceleration() const;
  ::apollo::canbus::Deceleration* mutable_deceleration();
  ::apollo::canbus::Deceleration* release_deceleration();
  void set_allocated_deceleration(::apollo::canbus::Deceleration* deceleration);

  // optional .apollo.canbus.VehicleSpd vehicle_spd = 11;
  bool has_vehicle_spd() const;
  void clear_vehicle_spd();
  static const int kVehicleSpdFieldNumber = 11;
  const ::apollo::canbus::VehicleSpd& vehicle_spd() const;
  ::apollo::canbus::VehicleSpd* mutable_vehicle_spd();
  ::apollo::canbus::VehicleSpd* release_vehicle_spd();
  void set_allocated_vehicle_spd(::apollo::canbus::VehicleSpd* vehicle_spd);

  // optional .apollo.canbus.Eps eps = 12;
  bool has_eps() const;
  void clear_eps();
  static const int kEpsFieldNumber = 12;
  const ::apollo::canbus::Eps& eps() const;
  ::apollo::canbus::Eps* mutable_eps();
  ::apollo::canbus::Eps* release_eps();
  void set_allocated_eps(::apollo::canbus::Eps* eps);

  // optional .apollo.canbus.Light light = 13;
  bool has_light() const;
  void clear_light();
  static const int kLightFieldNumber = 13;
  const ::apollo::canbus::Light& light() const;
  ::apollo::canbus::Light* mutable_light();
  ::apollo::canbus::Light* release_light();
  void set_allocated_light(::apollo::canbus::Light* light);

  // optional .apollo.canbus.Battery battery = 14;
  bool has_battery() const;
  void clear_battery();
  static const int kBatteryFieldNumber = 14;
  const ::apollo::canbus::Battery& battery() const;
  ::apollo::canbus::Battery* mutable_battery();
  ::apollo::canbus::Battery* release_battery();
  void set_allocated_battery(::apollo::canbus::Battery* battery);

  // optional .apollo.canbus.CheckResponseSignal check_response = 15;
  bool has_check_response() const;
  void clear_check_response();
  static const int kCheckResponseFieldNumber = 15;
  const ::apollo::canbus::CheckResponseSignal& check_response() const;
  ::apollo::canbus::CheckResponseSignal* mutable_check_response();
  ::apollo::canbus::CheckResponseSignal* release_check_response();
  void set_allocated_check_response(::apollo::canbus::CheckResponseSignal* check_response);

  // optional .apollo.canbus.License license = 16;
  bool has_license() const;
  void clear_license();
  static const int kLicenseFieldNumber = 16;
  const ::apollo::canbus::License& license() const;
  ::apollo::canbus::License* mutable_license();
  ::apollo::canbus::License* release_license();
  void set_allocated_license(::apollo::canbus::License* license);

  // optional .apollo.canbus.ChassisDetail.Type car_type = 1;
  bool has_car_type() const;
  void clear_car_type();
  static const int kCarTypeFieldNumber = 1;
  ::apollo::canbus::ChassisDetail_Type car_type() const;
  void set_car_type(::apollo::canbus::ChassisDetail_Type value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.ChassisDetail)
 private:
  void set_has_car_type();
  void clear_has_car_type();
  void set_has_basic();
  void clear_has_basic();
  void set_has_safety();
  void clear_has_safety();
  void set_has_gear();
  void clear_has_gear();
  void set_has_ems();
  void clear_has_ems();
  void set_has_esp();
  void clear_has_esp();
  void set_has_gas();
  void clear_has_gas();
  void set_has_epb();
  void clear_has_epb();
  void set_has_brake();
  void clear_has_brake();
  void set_has_deceleration();
  void clear_has_deceleration();
  void set_has_vehicle_spd();
  void clear_has_vehicle_spd();
  void set_has_eps();
  void clear_has_eps();
  void set_has_light();
  void clear_has_light();
  void set_has_battery();
  void clear_has_battery();
  void set_has_check_response();
  void clear_has_check_response();
  void set_has_license();
  void clear_has_license();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::apollo::canbus::BasicInfo* basic_;
  ::apollo::canbus::Safety* safety_;
  ::apollo::canbus::Gear* gear_;
  ::apollo::canbus::Ems* ems_;
  ::apollo::canbus::Esp* esp_;
  ::apollo::canbus::Gas* gas_;
  ::apollo::canbus::Epb* epb_;
  ::apollo::canbus::Brake* brake_;
  ::apollo::canbus::Deceleration* deceleration_;
  ::apollo::canbus::VehicleSpd* vehicle_spd_;
  ::apollo::canbus::Eps* eps_;
  ::apollo::canbus::Light* light_;
  ::apollo::canbus::Battery* battery_;
  ::apollo::canbus::CheckResponseSignal* check_response_;
  ::apollo::canbus::License* license_;
  int car_type_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CheckResponseSignal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.CheckResponseSignal) */ {
 public:
  CheckResponseSignal();
  virtual ~CheckResponseSignal();

  CheckResponseSignal(const CheckResponseSignal& from);

  inline CheckResponseSignal& operator=(const CheckResponseSignal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckResponseSignal& default_instance();

  static inline const CheckResponseSignal* internal_default_instance() {
    return reinterpret_cast<const CheckResponseSignal*>(
               &_CheckResponseSignal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(CheckResponseSignal* other);

  // implements Message ----------------------------------------------

  inline CheckResponseSignal* New() const PROTOBUF_FINAL { return New(NULL); }

  CheckResponseSignal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CheckResponseSignal& from);
  void MergeFrom(const CheckResponseSignal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CheckResponseSignal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_eps_online = 1 [default = false];
  bool has_is_eps_online() const;
  void clear_is_eps_online();
  static const int kIsEpsOnlineFieldNumber = 1;
  bool is_eps_online() const;
  void set_is_eps_online(bool value);

  // optional bool is_epb_online = 2 [default = false];
  bool has_is_epb_online() const;
  void clear_is_epb_online();
  static const int kIsEpbOnlineFieldNumber = 2;
  bool is_epb_online() const;
  void set_is_epb_online(bool value);

  // optional bool is_esp_online = 3 [default = false];
  bool has_is_esp_online() const;
  void clear_is_esp_online();
  static const int kIsEspOnlineFieldNumber = 3;
  bool is_esp_online() const;
  void set_is_esp_online(bool value);

  // optional bool is_vtog_online = 4 [default = false];
  bool has_is_vtog_online() const;
  void clear_is_vtog_online();
  static const int kIsVtogOnlineFieldNumber = 4;
  bool is_vtog_online() const;
  void set_is_vtog_online(bool value);

  // optional bool is_scu_online = 5 [default = false];
  bool has_is_scu_online() const;
  void clear_is_scu_online();
  static const int kIsScuOnlineFieldNumber = 5;
  bool is_scu_online() const;
  void set_is_scu_online(bool value);

  // optional bool is_switch_online = 6 [default = false];
  bool has_is_switch_online() const;
  void clear_is_switch_online();
  static const int kIsSwitchOnlineFieldNumber = 6;
  bool is_switch_online() const;
  void set_is_switch_online(bool value);

  // optional bool is_vcu_online = 7 [default = false];
  bool has_is_vcu_online() const;
  void clear_is_vcu_online();
  static const int kIsVcuOnlineFieldNumber = 7;
  bool is_vcu_online() const;
  void set_is_vcu_online(bool value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.CheckResponseSignal)
 private:
  void set_has_is_eps_online();
  void clear_has_is_eps_online();
  void set_has_is_epb_online();
  void clear_has_is_epb_online();
  void set_has_is_esp_online();
  void clear_has_is_esp_online();
  void set_has_is_vtog_online();
  void clear_has_is_vtog_online();
  void set_has_is_scu_online();
  void clear_has_is_scu_online();
  void set_has_is_switch_online();
  void clear_has_is_switch_online();
  void set_has_is_vcu_online();
  void clear_has_is_vcu_online();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool is_eps_online_;
  bool is_epb_online_;
  bool is_esp_online_;
  bool is_vtog_online_;
  bool is_scu_online_;
  bool is_switch_online_;
  bool is_vcu_online_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Battery : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Battery) */ {
 public:
  Battery();
  virtual ~Battery();

  Battery(const Battery& from);

  inline Battery& operator=(const Battery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Battery& default_instance();

  static inline const Battery* internal_default_instance() {
    return reinterpret_cast<const Battery*>(
               &_Battery_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Battery* other);

  // implements Message ----------------------------------------------

  inline Battery* New() const PROTOBUF_FINAL { return New(NULL); }

  Battery* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Battery& from);
  void MergeFrom(const Battery& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Battery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double battery_percent = 1;
  bool has_battery_percent() const;
  void clear_battery_percent();
  static const int kBatteryPercentFieldNumber = 1;
  double battery_percent() const;
  void set_battery_percent(double value);

  // optional double fuel_level = 2;
  bool has_fuel_level() const;
  void clear_fuel_level();
  static const int kFuelLevelFieldNumber = 2;
  double fuel_level() const;
  void set_fuel_level(double value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Battery)
 private:
  void set_has_battery_percent();
  void clear_has_battery_percent();
  void set_has_fuel_level();
  void clear_has_fuel_level();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double battery_percent_;
  double fuel_level_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Light : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Light) */ {
 public:
  Light();
  virtual ~Light();

  Light(const Light& from);

  inline Light& operator=(const Light& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Light& default_instance();

  static inline const Light* internal_default_instance() {
    return reinterpret_cast<const Light*>(
               &_Light_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Light* other);

  // implements Message ----------------------------------------------

  inline Light* New() const PROTOBUF_FINAL { return New(NULL); }

  Light* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Light& from);
  void MergeFrom(const Light& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Light* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Light_TurnLightType TurnLightType;
  static const TurnLightType TURN_LIGHT_OFF =
    Light_TurnLightType_TURN_LIGHT_OFF;
  static const TurnLightType TURN_LEFT_ON =
    Light_TurnLightType_TURN_LEFT_ON;
  static const TurnLightType TURN_RIGHT_ON =
    Light_TurnLightType_TURN_RIGHT_ON;
  static const TurnLightType TURN_LIGHT_ON =
    Light_TurnLightType_TURN_LIGHT_ON;
  static inline bool TurnLightType_IsValid(int value) {
    return Light_TurnLightType_IsValid(value);
  }
  static const TurnLightType TurnLightType_MIN =
    Light_TurnLightType_TurnLightType_MIN;
  static const TurnLightType TurnLightType_MAX =
    Light_TurnLightType_TurnLightType_MAX;
  static const int TurnLightType_ARRAYSIZE =
    Light_TurnLightType_TurnLightType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TurnLightType_descriptor() {
    return Light_TurnLightType_descriptor();
  }
  static inline const ::std::string& TurnLightType_Name(TurnLightType value) {
    return Light_TurnLightType_Name(value);
  }
  static inline bool TurnLightType_Parse(const ::std::string& name,
      TurnLightType* value) {
    return Light_TurnLightType_Parse(name, value);
  }

  typedef Light_LampType LampType;
  static const LampType BEAM_OFF =
    Light_LampType_BEAM_OFF;
  static const LampType HIGH_BEAM_ON =
    Light_LampType_HIGH_BEAM_ON;
  static const LampType LOW_BEAM_ON =
    Light_LampType_LOW_BEAM_ON;
  static inline bool LampType_IsValid(int value) {
    return Light_LampType_IsValid(value);
  }
  static const LampType LampType_MIN =
    Light_LampType_LampType_MIN;
  static const LampType LampType_MAX =
    Light_LampType_LampType_MAX;
  static const int LampType_ARRAYSIZE =
    Light_LampType_LampType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LampType_descriptor() {
    return Light_LampType_descriptor();
  }
  static inline const ::std::string& LampType_Name(LampType value) {
    return Light_LampType_Name(value);
  }
  static inline bool LampType_Parse(const ::std::string& name,
      LampType* value) {
    return Light_LampType_Parse(name, value);
  }

  typedef Light_LincolnLampType LincolnLampType;
  static const LincolnLampType BEAM_NULL =
    Light_LincolnLampType_BEAM_NULL;
  static const LincolnLampType BEAM_FLASH_TO_PASS =
    Light_LincolnLampType_BEAM_FLASH_TO_PASS;
  static const LincolnLampType BEAM_HIGH =
    Light_LincolnLampType_BEAM_HIGH;
  static const LincolnLampType BEAM_INVALID =
    Light_LincolnLampType_BEAM_INVALID;
  static inline bool LincolnLampType_IsValid(int value) {
    return Light_LincolnLampType_IsValid(value);
  }
  static const LincolnLampType LincolnLampType_MIN =
    Light_LincolnLampType_LincolnLampType_MIN;
  static const LincolnLampType LincolnLampType_MAX =
    Light_LincolnLampType_LincolnLampType_MAX;
  static const int LincolnLampType_ARRAYSIZE =
    Light_LincolnLampType_LincolnLampType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LincolnLampType_descriptor() {
    return Light_LincolnLampType_descriptor();
  }
  static inline const ::std::string& LincolnLampType_Name(LincolnLampType value) {
    return Light_LincolnLampType_Name(value);
  }
  static inline bool LincolnLampType_Parse(const ::std::string& name,
      LincolnLampType* value) {
    return Light_LincolnLampType_Parse(name, value);
  }

  typedef Light_LincolnWiperType LincolnWiperType;
  static const LincolnWiperType WIPER_OFF =
    Light_LincolnWiperType_WIPER_OFF;
  static const LincolnWiperType WIPER_AUTO_OFF =
    Light_LincolnWiperType_WIPER_AUTO_OFF;
  static const LincolnWiperType WIPER_OFF_MOVING =
    Light_LincolnWiperType_WIPER_OFF_MOVING;
  static const LincolnWiperType WIPER_MANUAL_OFF =
    Light_LincolnWiperType_WIPER_MANUAL_OFF;
  static const LincolnWiperType WIPER_MANUAL_ON =
    Light_LincolnWiperType_WIPER_MANUAL_ON;
  static const LincolnWiperType WIPER_MANUAL_LOW =
    Light_LincolnWiperType_WIPER_MANUAL_LOW;
  static const LincolnWiperType WIPER_MANUAL_HIGH =
    Light_LincolnWiperType_WIPER_MANUAL_HIGH;
  static const LincolnWiperType WIPER_MIST_FLICK =
    Light_LincolnWiperType_WIPER_MIST_FLICK;
  static const LincolnWiperType WIPER_WASH =
    Light_LincolnWiperType_WIPER_WASH;
  static const LincolnWiperType WIPER_AUTO_LOW =
    Light_LincolnWiperType_WIPER_AUTO_LOW;
  static const LincolnWiperType WIPER_AUTO_HIGH =
    Light_LincolnWiperType_WIPER_AUTO_HIGH;
  static const LincolnWiperType WIPER_COURTESY_WIPE =
    Light_LincolnWiperType_WIPER_COURTESY_WIPE;
  static const LincolnWiperType WIPER_AUTO_ADJUST =
    Light_LincolnWiperType_WIPER_AUTO_ADJUST;
  static const LincolnWiperType WIPER_RESERVED =
    Light_LincolnWiperType_WIPER_RESERVED;
  static const LincolnWiperType WIPER_STALLED =
    Light_LincolnWiperType_WIPER_STALLED;
  static const LincolnWiperType WIPER_NO_DATA =
    Light_LincolnWiperType_WIPER_NO_DATA;
  static inline bool LincolnWiperType_IsValid(int value) {
    return Light_LincolnWiperType_IsValid(value);
  }
  static const LincolnWiperType LincolnWiperType_MIN =
    Light_LincolnWiperType_LincolnWiperType_MIN;
  static const LincolnWiperType LincolnWiperType_MAX =
    Light_LincolnWiperType_LincolnWiperType_MAX;
  static const int LincolnWiperType_ARRAYSIZE =
    Light_LincolnWiperType_LincolnWiperType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LincolnWiperType_descriptor() {
    return Light_LincolnWiperType_descriptor();
  }
  static inline const ::std::string& LincolnWiperType_Name(LincolnWiperType value) {
    return Light_LincolnWiperType_Name(value);
  }
  static inline bool LincolnWiperType_Parse(const ::std::string& name,
      LincolnWiperType* value) {
    return Light_LincolnWiperType_Parse(name, value);
  }

  typedef Light_LincolnAmbientType LincolnAmbientType;
  static const LincolnAmbientType AMBIENT_DARK =
    Light_LincolnAmbientType_AMBIENT_DARK;
  static const LincolnAmbientType AMBIENT_LIGHT =
    Light_LincolnAmbientType_AMBIENT_LIGHT;
  static const LincolnAmbientType AMBIENT_TWILIGHT =
    Light_LincolnAmbientType_AMBIENT_TWILIGHT;
  static const LincolnAmbientType AMBIENT_TUNNEL_ON =
    Light_LincolnAmbientType_AMBIENT_TUNNEL_ON;
  static const LincolnAmbientType AMBIENT_TUNNEL_OFF =
    Light_LincolnAmbientType_AMBIENT_TUNNEL_OFF;
  static const LincolnAmbientType AMBIENT_INVALID =
    Light_LincolnAmbientType_AMBIENT_INVALID;
  static const LincolnAmbientType AMBIENT_NO_DATA =
    Light_LincolnAmbientType_AMBIENT_NO_DATA;
  static inline bool LincolnAmbientType_IsValid(int value) {
    return Light_LincolnAmbientType_IsValid(value);
  }
  static const LincolnAmbientType LincolnAmbientType_MIN =
    Light_LincolnAmbientType_LincolnAmbientType_MIN;
  static const LincolnAmbientType LincolnAmbientType_MAX =
    Light_LincolnAmbientType_LincolnAmbientType_MAX;
  static const int LincolnAmbientType_ARRAYSIZE =
    Light_LincolnAmbientType_LincolnAmbientType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LincolnAmbientType_descriptor() {
    return Light_LincolnAmbientType_descriptor();
  }
  static inline const ::std::string& LincolnAmbientType_Name(LincolnAmbientType value) {
    return Light_LincolnAmbientType_Name(value);
  }
  static inline bool LincolnAmbientType_Parse(const ::std::string& name,
      LincolnAmbientType* value) {
    return Light_LincolnAmbientType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .apollo.canbus.Light.TurnLightType turn_light_type = 1;
  bool has_turn_light_type() const;
  void clear_turn_light_type();
  static const int kTurnLightTypeFieldNumber = 1;
  ::apollo::canbus::Light_TurnLightType turn_light_type() const;
  void set_turn_light_type(::apollo::canbus::Light_TurnLightType value);

  // optional .apollo.canbus.Light.LampType lamp_type = 2;
  bool has_lamp_type() const;
  void clear_lamp_type();
  static const int kLampTypeFieldNumber = 2;
  ::apollo::canbus::Light_LampType lamp_type() const;
  void set_lamp_type(::apollo::canbus::Light_LampType value);

  // optional bool is_brake_lamp_on = 3;
  bool has_is_brake_lamp_on() const;
  void clear_is_brake_lamp_on();
  static const int kIsBrakeLampOnFieldNumber = 3;
  bool is_brake_lamp_on() const;
  void set_is_brake_lamp_on(bool value);

  // optional bool is_auto_light = 4;
  bool has_is_auto_light() const;
  void clear_is_auto_light();
  static const int kIsAutoLightFieldNumber = 4;
  bool is_auto_light() const;
  void set_is_auto_light(bool value);

  // optional bool is_horn_on = 7;
  bool has_is_horn_on() const;
  void clear_is_horn_on();
  static const int kIsHornOnFieldNumber = 7;
  bool is_horn_on() const;
  void set_is_horn_on(bool value);

  // optional int32 wiper_gear = 5;
  bool has_wiper_gear() const;
  void clear_wiper_gear();
  static const int kWiperGearFieldNumber = 5;
  ::google::protobuf::int32 wiper_gear() const;
  void set_wiper_gear(::google::protobuf::int32 value);

  // optional int32 lotion_gear = 6;
  bool has_lotion_gear() const;
  void clear_lotion_gear();
  static const int kLotionGearFieldNumber = 6;
  ::google::protobuf::int32 lotion_gear() const;
  void set_lotion_gear(::google::protobuf::int32 value);

  // optional .apollo.canbus.Light.LincolnLampType lincoln_lamp_type = 8;
  bool has_lincoln_lamp_type() const;
  void clear_lincoln_lamp_type();
  static const int kLincolnLampTypeFieldNumber = 8;
  ::apollo::canbus::Light_LincolnLampType lincoln_lamp_type() const;
  void set_lincoln_lamp_type(::apollo::canbus::Light_LincolnLampType value);

  // optional .apollo.canbus.Light.LincolnWiperType lincoln_wiper = 9;
  bool has_lincoln_wiper() const;
  void clear_lincoln_wiper();
  static const int kLincolnWiperFieldNumber = 9;
  ::apollo::canbus::Light_LincolnWiperType lincoln_wiper() const;
  void set_lincoln_wiper(::apollo::canbus::Light_LincolnWiperType value);

  // optional .apollo.canbus.Light.LincolnAmbientType lincoln_ambient = 10;
  bool has_lincoln_ambient() const;
  void clear_lincoln_ambient();
  static const int kLincolnAmbientFieldNumber = 10;
  ::apollo::canbus::Light_LincolnAmbientType lincoln_ambient() const;
  void set_lincoln_ambient(::apollo::canbus::Light_LincolnAmbientType value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Light)
 private:
  void set_has_turn_light_type();
  void clear_has_turn_light_type();
  void set_has_lamp_type();
  void clear_has_lamp_type();
  void set_has_is_brake_lamp_on();
  void clear_has_is_brake_lamp_on();
  void set_has_is_auto_light();
  void clear_has_is_auto_light();
  void set_has_wiper_gear();
  void clear_has_wiper_gear();
  void set_has_lotion_gear();
  void clear_has_lotion_gear();
  void set_has_is_horn_on();
  void clear_has_is_horn_on();
  void set_has_lincoln_lamp_type();
  void clear_has_lincoln_lamp_type();
  void set_has_lincoln_wiper();
  void clear_has_lincoln_wiper();
  void set_has_lincoln_ambient();
  void clear_has_lincoln_ambient();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int turn_light_type_;
  int lamp_type_;
  bool is_brake_lamp_on_;
  bool is_auto_light_;
  bool is_horn_on_;
  ::google::protobuf::int32 wiper_gear_;
  ::google::protobuf::int32 lotion_gear_;
  int lincoln_lamp_type_;
  int lincoln_wiper_;
  int lincoln_ambient_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Eps : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Eps) */ {
 public:
  Eps();
  virtual ~Eps();

  Eps(const Eps& from);

  inline Eps& operator=(const Eps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Eps& default_instance();

  static inline const Eps* internal_default_instance() {
    return reinterpret_cast<const Eps*>(
               &_Eps_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Eps* other);

  // implements Message ----------------------------------------------

  inline Eps* New() const PROTOBUF_FINAL { return New(NULL); }

  Eps* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Eps& from);
  void MergeFrom(const Eps& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Eps* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Eps_Type Type;
  static const Type NOT_AVAILABLE =
    Eps_Type_NOT_AVAILABLE;
  static const Type READY =
    Eps_Type_READY;
  static const Type ACTIVE =
    Eps_Type_ACTIVE;
  static const Type INVALID =
    Eps_Type_INVALID;
  static inline bool Type_IsValid(int value) {
    return Eps_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Eps_Type_Type_MIN;
  static const Type Type_MAX =
    Eps_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Eps_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Eps_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Eps_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Eps_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double eps_driver_hand_torq = 3;
  bool has_eps_driver_hand_torq() const;
  void clear_eps_driver_hand_torq();
  static const int kEpsDriverHandTorqFieldNumber = 3;
  double eps_driver_hand_torq() const;
  void set_eps_driver_hand_torq(double value);

  // optional .apollo.canbus.Eps.Type eps_control_state = 2;
  bool has_eps_control_state() const;
  void clear_eps_control_state();
  static const int kEpsControlStateFieldNumber = 2;
  ::apollo::canbus::Eps_Type eps_control_state() const;
  void set_eps_control_state(::apollo::canbus::Eps_Type value);

  // optional bool is_eps_fail = 1;
  bool has_is_eps_fail() const;
  void clear_is_eps_fail();
  static const int kIsEpsFailFieldNumber = 1;
  bool is_eps_fail() const;
  void set_is_eps_fail(bool value);

  // optional bool is_steering_angle_valid = 4;
  bool has_is_steering_angle_valid() const;
  void clear_is_steering_angle_valid();
  static const int kIsSteeringAngleValidFieldNumber = 4;
  bool is_steering_angle_valid() const;
  void set_is_steering_angle_valid(bool value);

  // optional bool is_trimming_status = 7;
  bool has_is_trimming_status() const;
  void clear_is_trimming_status();
  static const int kIsTrimmingStatusFieldNumber = 7;
  bool is_trimming_status() const;
  void set_is_trimming_status(bool value);

  // optional bool is_calibration_status = 8;
  bool has_is_calibration_status() const;
  void clear_is_calibration_status();
  static const int kIsCalibrationStatusFieldNumber = 8;
  bool is_calibration_status() const;
  void set_is_calibration_status(bool value);

  // optional double steering_angle = 5;
  bool has_steering_angle() const;
  void clear_steering_angle();
  static const int kSteeringAngleFieldNumber = 5;
  double steering_angle() const;
  void set_steering_angle(double value);

  // optional double steering_angle_spd = 6;
  bool has_steering_angle_spd() const;
  void clear_steering_angle_spd();
  static const int kSteeringAngleSpdFieldNumber = 6;
  double steering_angle_spd() const;
  void set_steering_angle_spd(double value);

  // optional int32 allow_enter_autonomous_mode = 10;
  bool has_allow_enter_autonomous_mode() const;
  void clear_allow_enter_autonomous_mode();
  static const int kAllowEnterAutonomousModeFieldNumber = 10;
  ::google::protobuf::int32 allow_enter_autonomous_mode() const;
  void set_allow_enter_autonomous_mode(::google::protobuf::int32 value);

  // optional int32 current_driving_mode = 11;
  bool has_current_driving_mode() const;
  void clear_current_driving_mode();
  static const int kCurrentDrivingModeFieldNumber = 11;
  ::google::protobuf::int32 current_driving_mode() const;
  void set_current_driving_mode(::google::protobuf::int32 value);

  // optional double steering_angle_cmd = 12;
  bool has_steering_angle_cmd() const;
  void clear_steering_angle_cmd();
  static const int kSteeringAngleCmdFieldNumber = 12;
  double steering_angle_cmd() const;
  void set_steering_angle_cmd(double value);

  // optional double vehicle_speed = 13;
  bool has_vehicle_speed() const;
  void clear_vehicle_speed();
  static const int kVehicleSpeedFieldNumber = 13;
  double vehicle_speed() const;
  void set_vehicle_speed(double value);

  // optional double epas_torque = 14;
  bool has_epas_torque() const;
  void clear_epas_torque();
  static const int kEpasTorqueFieldNumber = 14;
  double epas_torque() const;
  void set_epas_torque(double value);

  // optional bool is_failure_status = 9;
  bool has_is_failure_status() const;
  void clear_is_failure_status();
  static const int kIsFailureStatusFieldNumber = 9;
  bool is_failure_status() const;
  void set_is_failure_status(bool value);

  // optional bool steering_enabled = 15;
  bool has_steering_enabled() const;
  void clear_steering_enabled();
  static const int kSteeringEnabledFieldNumber = 15;
  bool steering_enabled() const;
  void set_steering_enabled(bool value);

  // optional bool driver_override = 16;
  bool has_driver_override() const;
  void clear_driver_override();
  static const int kDriverOverrideFieldNumber = 16;
  bool driver_override() const;
  void set_driver_override(bool value);

  // optional bool driver_activity = 17;
  bool has_driver_activity() const;
  void clear_driver_activity();
  static const int kDriverActivityFieldNumber = 17;
  bool driver_activity() const;
  void set_driver_activity(bool value);

  // optional bool watchdog_fault = 18;
  bool has_watchdog_fault() const;
  void clear_watchdog_fault();
  static const int kWatchdogFaultFieldNumber = 18;
  bool watchdog_fault() const;
  void set_watchdog_fault(bool value);

  // optional bool channel_1_fault = 19;
  bool has_channel_1_fault() const;
  void clear_channel_1_fault();
  static const int kChannel1FaultFieldNumber = 19;
  bool channel_1_fault() const;
  void set_channel_1_fault(bool value);

  // optional bool channel_2_fault = 20;
  bool has_channel_2_fault() const;
  void clear_channel_2_fault();
  static const int kChannel2FaultFieldNumber = 20;
  bool channel_2_fault() const;
  void set_channel_2_fault(bool value);

  // optional bool calibration_fault = 21;
  bool has_calibration_fault() const;
  void clear_calibration_fault();
  static const int kCalibrationFaultFieldNumber = 21;
  bool calibration_fault() const;
  void set_calibration_fault(bool value);

  // optional double timestamp_65 = 23;
  bool has_timestamp_65() const;
  void clear_timestamp_65();
  static const int kTimestamp65FieldNumber = 23;
  double timestamp_65() const;
  void set_timestamp_65(double value);

  // optional bool connector_fault = 22;
  bool has_connector_fault() const;
  void clear_connector_fault();
  static const int kConnectorFaultFieldNumber = 22;
  bool connector_fault() const;
  void set_connector_fault(bool value);

  // optional int32 major_version = 24;
  bool has_major_version() const;
  void clear_major_version();
  static const int kMajorVersionFieldNumber = 24;
  ::google::protobuf::int32 major_version() const;
  void set_major_version(::google::protobuf::int32 value);

  // optional int32 minor_version = 25;
  bool has_minor_version() const;
  void clear_minor_version();
  static const int kMinorVersionFieldNumber = 25;
  ::google::protobuf::int32 minor_version() const;
  void set_minor_version(::google::protobuf::int32 value);

  // optional int32 build_number = 26;
  bool has_build_number() const;
  void clear_build_number();
  static const int kBuildNumberFieldNumber = 26;
  ::google::protobuf::int32 build_number() const;
  void set_build_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Eps)
 private:
  void set_has_is_eps_fail();
  void clear_has_is_eps_fail();
  void set_has_eps_control_state();
  void clear_has_eps_control_state();
  void set_has_eps_driver_hand_torq();
  void clear_has_eps_driver_hand_torq();
  void set_has_is_steering_angle_valid();
  void clear_has_is_steering_angle_valid();
  void set_has_steering_angle();
  void clear_has_steering_angle();
  void set_has_steering_angle_spd();
  void clear_has_steering_angle_spd();
  void set_has_is_trimming_status();
  void clear_has_is_trimming_status();
  void set_has_is_calibration_status();
  void clear_has_is_calibration_status();
  void set_has_is_failure_status();
  void clear_has_is_failure_status();
  void set_has_allow_enter_autonomous_mode();
  void clear_has_allow_enter_autonomous_mode();
  void set_has_current_driving_mode();
  void clear_has_current_driving_mode();
  void set_has_steering_angle_cmd();
  void clear_has_steering_angle_cmd();
  void set_has_vehicle_speed();
  void clear_has_vehicle_speed();
  void set_has_epas_torque();
  void clear_has_epas_torque();
  void set_has_steering_enabled();
  void clear_has_steering_enabled();
  void set_has_driver_override();
  void clear_has_driver_override();
  void set_has_driver_activity();
  void clear_has_driver_activity();
  void set_has_watchdog_fault();
  void clear_has_watchdog_fault();
  void set_has_channel_1_fault();
  void clear_has_channel_1_fault();
  void set_has_channel_2_fault();
  void clear_has_channel_2_fault();
  void set_has_calibration_fault();
  void clear_has_calibration_fault();
  void set_has_connector_fault();
  void clear_has_connector_fault();
  void set_has_timestamp_65();
  void clear_has_timestamp_65();
  void set_has_major_version();
  void clear_has_major_version();
  void set_has_minor_version();
  void clear_has_minor_version();
  void set_has_build_number();
  void clear_has_build_number();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double eps_driver_hand_torq_;
  int eps_control_state_;
  bool is_eps_fail_;
  bool is_steering_angle_valid_;
  bool is_trimming_status_;
  bool is_calibration_status_;
  double steering_angle_;
  double steering_angle_spd_;
  ::google::protobuf::int32 allow_enter_autonomous_mode_;
  ::google::protobuf::int32 current_driving_mode_;
  double steering_angle_cmd_;
  double vehicle_speed_;
  double epas_torque_;
  bool is_failure_status_;
  bool steering_enabled_;
  bool driver_override_;
  bool driver_activity_;
  bool watchdog_fault_;
  bool channel_1_fault_;
  bool channel_2_fault_;
  bool calibration_fault_;
  double timestamp_65_;
  bool connector_fault_;
  ::google::protobuf::int32 major_version_;
  ::google::protobuf::int32 minor_version_;
  ::google::protobuf::int32 build_number_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehicleSpd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.VehicleSpd) */ {
 public:
  VehicleSpd();
  virtual ~VehicleSpd();

  VehicleSpd(const VehicleSpd& from);

  inline VehicleSpd& operator=(const VehicleSpd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleSpd& default_instance();

  static inline const VehicleSpd* internal_default_instance() {
    return reinterpret_cast<const VehicleSpd*>(
               &_VehicleSpd_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(VehicleSpd* other);

  // implements Message ----------------------------------------------

  inline VehicleSpd* New() const PROTOBUF_FINAL { return New(NULL); }

  VehicleSpd* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VehicleSpd& from);
  void MergeFrom(const VehicleSpd& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VehicleSpd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef VehicleSpd_Type Type;
  static const Type FORWARD =
    VehicleSpd_Type_FORWARD;
  static const Type BACKWARD =
    VehicleSpd_Type_BACKWARD;
  static const Type STANDSTILL =
    VehicleSpd_Type_STANDSTILL;
  static const Type INVALID =
    VehicleSpd_Type_INVALID;
  static inline bool Type_IsValid(int value) {
    return VehicleSpd_Type_IsValid(value);
  }
  static const Type Type_MIN =
    VehicleSpd_Type_Type_MIN;
  static const Type Type_MAX =
    VehicleSpd_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    VehicleSpd_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return VehicleSpd_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return VehicleSpd_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return VehicleSpd_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double vehicle_spd = 3 [default = 0];
  bool has_vehicle_spd() const;
  void clear_vehicle_spd();
  static const int kVehicleSpdFieldNumber = 3;
  double vehicle_spd() const;
  void set_vehicle_spd(double value);

  // optional bool is_vehicle_standstill = 1;
  bool has_is_vehicle_standstill() const;
  void clear_is_vehicle_standstill();
  static const int kIsVehicleStandstillFieldNumber = 1;
  bool is_vehicle_standstill() const;
  void set_is_vehicle_standstill(bool value);

  // optional bool is_vehicle_spd_valid = 2;
  bool has_is_vehicle_spd_valid() const;
  void clear_is_vehicle_spd_valid();
  static const int kIsVehicleSpdValidFieldNumber = 2;
  bool is_vehicle_spd_valid() const;
  void set_is_vehicle_spd_valid(bool value);

  // optional bool is_wheel_spd_rr_valid = 4;
  bool has_is_wheel_spd_rr_valid() const;
  void clear_is_wheel_spd_rr_valid();
  static const int kIsWheelSpdRrValidFieldNumber = 4;
  bool is_wheel_spd_rr_valid() const;
  void set_is_wheel_spd_rr_valid(bool value);

  // optional bool is_wheel_spd_rl_valid = 7;
  bool has_is_wheel_spd_rl_valid() const;
  void clear_is_wheel_spd_rl_valid();
  static const int kIsWheelSpdRlValidFieldNumber = 7;
  bool is_wheel_spd_rl_valid() const;
  void set_is_wheel_spd_rl_valid(bool value);

  // optional .apollo.canbus.VehicleSpd.Type wheel_direction_rr = 5;
  bool has_wheel_direction_rr() const;
  void clear_wheel_direction_rr();
  static const int kWheelDirectionRrFieldNumber = 5;
  ::apollo::canbus::VehicleSpd_Type wheel_direction_rr() const;
  void set_wheel_direction_rr(::apollo::canbus::VehicleSpd_Type value);

  // optional double wheel_spd_rr = 6;
  bool has_wheel_spd_rr() const;
  void clear_wheel_spd_rr();
  static const int kWheelSpdRrFieldNumber = 6;
  double wheel_spd_rr() const;
  void set_wheel_spd_rr(double value);

  // optional double wheel_spd_rl = 9;
  bool has_wheel_spd_rl() const;
  void clear_wheel_spd_rl();
  static const int kWheelSpdRlFieldNumber = 9;
  double wheel_spd_rl() const;
  void set_wheel_spd_rl(double value);

  // optional .apollo.canbus.VehicleSpd.Type wheel_direction_rl = 8;
  bool has_wheel_direction_rl() const;
  void clear_wheel_direction_rl();
  static const int kWheelDirectionRlFieldNumber = 8;
  ::apollo::canbus::VehicleSpd_Type wheel_direction_rl() const;
  void set_wheel_direction_rl(::apollo::canbus::VehicleSpd_Type value);

  // optional .apollo.canbus.VehicleSpd.Type wheel_direction_fr = 11;
  bool has_wheel_direction_fr() const;
  void clear_wheel_direction_fr();
  static const int kWheelDirectionFrFieldNumber = 11;
  ::apollo::canbus::VehicleSpd_Type wheel_direction_fr() const;
  void set_wheel_direction_fr(::apollo::canbus::VehicleSpd_Type value);

  // optional double wheel_spd_fr = 12;
  bool has_wheel_spd_fr() const;
  void clear_wheel_spd_fr();
  static const int kWheelSpdFrFieldNumber = 12;
  double wheel_spd_fr() const;
  void set_wheel_spd_fr(double value);

  // optional .apollo.canbus.VehicleSpd.Type wheel_direction_fl = 14;
  bool has_wheel_direction_fl() const;
  void clear_wheel_direction_fl();
  static const int kWheelDirectionFlFieldNumber = 14;
  ::apollo::canbus::VehicleSpd_Type wheel_direction_fl() const;
  void set_wheel_direction_fl(::apollo::canbus::VehicleSpd_Type value);

  // optional bool is_wheel_spd_fr_valid = 10;
  bool has_is_wheel_spd_fr_valid() const;
  void clear_is_wheel_spd_fr_valid();
  static const int kIsWheelSpdFrValidFieldNumber = 10;
  bool is_wheel_spd_fr_valid() const;
  void set_is_wheel_spd_fr_valid(bool value);

  // optional bool is_wheel_spd_fl_valid = 13;
  bool has_is_wheel_spd_fl_valid() const;
  void clear_is_wheel_spd_fl_valid();
  static const int kIsWheelSpdFlValidFieldNumber = 13;
  bool is_wheel_spd_fl_valid() const;
  void set_is_wheel_spd_fl_valid(bool value);

  // optional bool is_yaw_rate_valid = 16;
  bool has_is_yaw_rate_valid() const;
  void clear_is_yaw_rate_valid();
  static const int kIsYawRateValidFieldNumber = 16;
  bool is_yaw_rate_valid() const;
  void set_is_yaw_rate_valid(bool value);

  // optional bool is_ax_valid = 19;
  bool has_is_ax_valid() const;
  void clear_is_ax_valid();
  static const int kIsAxValidFieldNumber = 19;
  bool is_ax_valid() const;
  void set_is_ax_valid(bool value);

  // optional double wheel_spd_fl = 15;
  bool has_wheel_spd_fl() const;
  void clear_wheel_spd_fl();
  static const int kWheelSpdFlFieldNumber = 15;
  double wheel_spd_fl() const;
  void set_wheel_spd_fl(double value);

  // optional double yaw_rate = 17;
  bool has_yaw_rate() const;
  void clear_yaw_rate();
  static const int kYawRateFieldNumber = 17;
  double yaw_rate() const;
  void set_yaw_rate(double value);

  // optional double yaw_rate_offset = 18;
  bool has_yaw_rate_offset() const;
  void clear_yaw_rate_offset();
  static const int kYawRateOffsetFieldNumber = 18;
  double yaw_rate_offset() const;
  void set_yaw_rate_offset(double value);

  // optional double ax = 20;
  bool has_ax() const;
  void clear_ax();
  static const int kAxFieldNumber = 20;
  double ax() const;
  void set_ax(double value);

  // optional double ax_offset = 21;
  bool has_ax_offset() const;
  void clear_ax_offset();
  static const int kAxOffsetFieldNumber = 21;
  double ax_offset() const;
  void set_ax_offset(double value);

  // optional double ay = 23;
  bool has_ay() const;
  void clear_ay();
  static const int kAyFieldNumber = 23;
  double ay() const;
  void set_ay(double value);

  // optional double ay_offset = 24;
  bool has_ay_offset() const;
  void clear_ay_offset();
  static const int kAyOffsetFieldNumber = 24;
  double ay_offset() const;
  void set_ay_offset(double value);

  // optional double lat_acc = 25;
  bool has_lat_acc() const;
  void clear_lat_acc();
  static const int kLatAccFieldNumber = 25;
  double lat_acc() const;
  void set_lat_acc(double value);

  // optional double long_acc = 26;
  bool has_long_acc() const;
  void clear_long_acc();
  static const int kLongAccFieldNumber = 26;
  double long_acc() const;
  void set_long_acc(double value);

  // optional double vert_acc = 27;
  bool has_vert_acc() const;
  void clear_vert_acc();
  static const int kVertAccFieldNumber = 27;
  double vert_acc() const;
  void set_vert_acc(double value);

  // optional double roll_rate = 28;
  bool has_roll_rate() const;
  void clear_roll_rate();
  static const int kRollRateFieldNumber = 28;
  double roll_rate() const;
  void set_roll_rate(double value);

  // optional double acc_est = 29;
  bool has_acc_est() const;
  void clear_acc_est();
  static const int kAccEstFieldNumber = 29;
  double acc_est() const;
  void set_acc_est(double value);

  // optional double timestamp_sec = 30;
  bool has_timestamp_sec() const;
  void clear_timestamp_sec();
  static const int kTimestampSecFieldNumber = 30;
  double timestamp_sec() const;
  void set_timestamp_sec(double value);

  // optional bool is_ay_valid = 22;
  bool has_is_ay_valid() const;
  void clear_is_ay_valid();
  static const int kIsAyValidFieldNumber = 22;
  bool is_ay_valid() const;
  void set_is_ay_valid(bool value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.VehicleSpd)
 private:
  void set_has_is_vehicle_standstill();
  void clear_has_is_vehicle_standstill();
  void set_has_is_vehicle_spd_valid();
  void clear_has_is_vehicle_spd_valid();
  void set_has_vehicle_spd();
  void clear_has_vehicle_spd();
  void set_has_is_wheel_spd_rr_valid();
  void clear_has_is_wheel_spd_rr_valid();
  void set_has_wheel_direction_rr();
  void clear_has_wheel_direction_rr();
  void set_has_wheel_spd_rr();
  void clear_has_wheel_spd_rr();
  void set_has_is_wheel_spd_rl_valid();
  void clear_has_is_wheel_spd_rl_valid();
  void set_has_wheel_direction_rl();
  void clear_has_wheel_direction_rl();
  void set_has_wheel_spd_rl();
  void clear_has_wheel_spd_rl();
  void set_has_is_wheel_spd_fr_valid();
  void clear_has_is_wheel_spd_fr_valid();
  void set_has_wheel_direction_fr();
  void clear_has_wheel_direction_fr();
  void set_has_wheel_spd_fr();
  void clear_has_wheel_spd_fr();
  void set_has_is_wheel_spd_fl_valid();
  void clear_has_is_wheel_spd_fl_valid();
  void set_has_wheel_direction_fl();
  void clear_has_wheel_direction_fl();
  void set_has_wheel_spd_fl();
  void clear_has_wheel_spd_fl();
  void set_has_is_yaw_rate_valid();
  void clear_has_is_yaw_rate_valid();
  void set_has_yaw_rate();
  void clear_has_yaw_rate();
  void set_has_yaw_rate_offset();
  void clear_has_yaw_rate_offset();
  void set_has_is_ax_valid();
  void clear_has_is_ax_valid();
  void set_has_ax();
  void clear_has_ax();
  void set_has_ax_offset();
  void clear_has_ax_offset();
  void set_has_is_ay_valid();
  void clear_has_is_ay_valid();
  void set_has_ay();
  void clear_has_ay();
  void set_has_ay_offset();
  void clear_has_ay_offset();
  void set_has_lat_acc();
  void clear_has_lat_acc();
  void set_has_long_acc();
  void clear_has_long_acc();
  void set_has_vert_acc();
  void clear_has_vert_acc();
  void set_has_roll_rate();
  void clear_has_roll_rate();
  void set_has_acc_est();
  void clear_has_acc_est();
  void set_has_timestamp_sec();
  void clear_has_timestamp_sec();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double vehicle_spd_;
  bool is_vehicle_standstill_;
  bool is_vehicle_spd_valid_;
  bool is_wheel_spd_rr_valid_;
  bool is_wheel_spd_rl_valid_;
  int wheel_direction_rr_;
  double wheel_spd_rr_;
  double wheel_spd_rl_;
  int wheel_direction_rl_;
  int wheel_direction_fr_;
  double wheel_spd_fr_;
  int wheel_direction_fl_;
  bool is_wheel_spd_fr_valid_;
  bool is_wheel_spd_fl_valid_;
  bool is_yaw_rate_valid_;
  bool is_ax_valid_;
  double wheel_spd_fl_;
  double yaw_rate_;
  double yaw_rate_offset_;
  double ax_;
  double ax_offset_;
  double ay_;
  double ay_offset_;
  double lat_acc_;
  double long_acc_;
  double vert_acc_;
  double roll_rate_;
  double acc_est_;
  double timestamp_sec_;
  bool is_ay_valid_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Deceleration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Deceleration) */ {
 public:
  Deceleration();
  virtual ~Deceleration();

  Deceleration(const Deceleration& from);

  inline Deceleration& operator=(const Deceleration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Deceleration& default_instance();

  static inline const Deceleration* internal_default_instance() {
    return reinterpret_cast<const Deceleration*>(
               &_Deceleration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Deceleration* other);

  // implements Message ----------------------------------------------

  inline Deceleration* New() const PROTOBUF_FINAL { return New(NULL); }

  Deceleration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Deceleration& from);
  void MergeFrom(const Deceleration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Deceleration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double deceleration = 3 [default = 0];
  bool has_deceleration() const;
  void clear_deceleration();
  static const int kDecelerationFieldNumber = 3;
  double deceleration() const;
  void set_deceleration(double value);

  // optional double is_evb_fail = 4;
  bool has_is_evb_fail() const;
  void clear_is_evb_fail();
  static const int kIsEvbFailFieldNumber = 4;
  double is_evb_fail() const;
  void set_is_evb_fail(double value);

  // optional double evb_pressure = 5 [default = 0];
  bool has_evb_pressure() const;
  void clear_evb_pressure();
  static const int kEvbPressureFieldNumber = 5;
  double evb_pressure() const;
  void set_evb_pressure(double value);

  // optional double brake_pressure = 6 [default = 0];
  bool has_brake_pressure() const;
  void clear_brake_pressure();
  static const int kBrakePressureFieldNumber = 6;
  double brake_pressure() const;
  void set_brake_pressure(double value);

  // optional double brake_pressure_spd = 7 [default = 0];
  bool has_brake_pressure_spd() const;
  void clear_brake_pressure_spd();
  static const int kBrakePressureSpdFieldNumber = 7;
  double brake_pressure_spd() const;
  void set_brake_pressure_spd(double value);

  // optional bool is_deceleration_available = 1;
  bool has_is_deceleration_available() const;
  void clear_is_deceleration_available();
  static const int kIsDecelerationAvailableFieldNumber = 1;
  bool is_deceleration_available() const;
  void set_is_deceleration_available(bool value);

  // optional bool is_deceleration_active = 2;
  bool has_is_deceleration_active() const;
  void clear_is_deceleration_active();
  static const int kIsDecelerationActiveFieldNumber = 2;
  bool is_deceleration_active() const;
  void set_is_deceleration_active(bool value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Deceleration)
 private:
  void set_has_is_deceleration_available();
  void clear_has_is_deceleration_available();
  void set_has_is_deceleration_active();
  void clear_has_is_deceleration_active();
  void set_has_deceleration();
  void clear_has_deceleration();
  void set_has_is_evb_fail();
  void clear_has_is_evb_fail();
  void set_has_evb_pressure();
  void clear_has_evb_pressure();
  void set_has_brake_pressure();
  void clear_has_brake_pressure();
  void set_has_brake_pressure_spd();
  void clear_has_brake_pressure_spd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double deceleration_;
  double is_evb_fail_;
  double evb_pressure_;
  double brake_pressure_;
  double brake_pressure_spd_;
  bool is_deceleration_available_;
  bool is_deceleration_active_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Brake : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Brake) */ {
 public:
  Brake();
  virtual ~Brake();

  Brake(const Brake& from);

  inline Brake& operator=(const Brake& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Brake& default_instance();

  static inline const Brake* internal_default_instance() {
    return reinterpret_cast<const Brake*>(
               &_Brake_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Brake* other);

  // implements Message ----------------------------------------------

  inline Brake* New() const PROTOBUF_FINAL { return New(NULL); }

  Brake* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Brake& from);
  void MergeFrom(const Brake& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Brake* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Brake_HSAStatusType HSAStatusType;
  static const HSAStatusType HSA_INACTIVE =
    Brake_HSAStatusType_HSA_INACTIVE;
  static const HSAStatusType HSA_FINDING_GRADIENT =
    Brake_HSAStatusType_HSA_FINDING_GRADIENT;
  static const HSAStatusType HSA_ACTIVE_PRESSED =
    Brake_HSAStatusType_HSA_ACTIVE_PRESSED;
  static const HSAStatusType HSA_ACTIVE_RELEASED =
    Brake_HSAStatusType_HSA_ACTIVE_RELEASED;
  static const HSAStatusType HSA_FAST_RELEASE =
    Brake_HSAStatusType_HSA_FAST_RELEASE;
  static const HSAStatusType HSA_SLOW_RELEASE =
    Brake_HSAStatusType_HSA_SLOW_RELEASE;
  static const HSAStatusType HSA_FAILED =
    Brake_HSAStatusType_HSA_FAILED;
  static const HSAStatusType HSA_UNDEFINED =
    Brake_HSAStatusType_HSA_UNDEFINED;
  static inline bool HSAStatusType_IsValid(int value) {
    return Brake_HSAStatusType_IsValid(value);
  }
  static const HSAStatusType HSAStatusType_MIN =
    Brake_HSAStatusType_HSAStatusType_MIN;
  static const HSAStatusType HSAStatusType_MAX =
    Brake_HSAStatusType_HSAStatusType_MAX;
  static const int HSAStatusType_ARRAYSIZE =
    Brake_HSAStatusType_HSAStatusType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HSAStatusType_descriptor() {
    return Brake_HSAStatusType_descriptor();
  }
  static inline const ::std::string& HSAStatusType_Name(HSAStatusType value) {
    return Brake_HSAStatusType_Name(value);
  }
  static inline bool HSAStatusType_Parse(const ::std::string& name,
      HSAStatusType* value) {
    return Brake_HSAStatusType_Parse(name, value);
  }

  typedef Brake_HSAModeType HSAModeType;
  static const HSAModeType HSA_OFF =
    Brake_HSAModeType_HSA_OFF;
  static const HSAModeType HSA_AUTO =
    Brake_HSAModeType_HSA_AUTO;
  static const HSAModeType HSA_MANUAL =
    Brake_HSAModeType_HSA_MANUAL;
  static const HSAModeType HSA_MODE_UNDEFINED =
    Brake_HSAModeType_HSA_MODE_UNDEFINED;
  static inline bool HSAModeType_IsValid(int value) {
    return Brake_HSAModeType_IsValid(value);
  }
  static const HSAModeType HSAModeType_MIN =
    Brake_HSAModeType_HSAModeType_MIN;
  static const HSAModeType HSAModeType_MAX =
    Brake_HSAModeType_HSAModeType_MAX;
  static const int HSAModeType_ARRAYSIZE =
    Brake_HSAModeType_HSAModeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HSAModeType_descriptor() {
    return Brake_HSAModeType_descriptor();
  }
  static inline const ::std::string& HSAModeType_Name(HSAModeType value) {
    return Brake_HSAModeType_Name(value);
  }
  static inline bool HSAModeType_Parse(const ::std::string& name,
      HSAModeType* value) {
    return Brake_HSAModeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double brake_pedal_position = 5;
  bool has_brake_pedal_position() const;
  void clear_brake_pedal_position();
  static const int kBrakePedalPositionFieldNumber = 5;
  double brake_pedal_position() const;
  void set_brake_pedal_position(double value);

  // optional bool is_brake_pedal_pressed = 1 [default = false];
  bool has_is_brake_pedal_pressed() const;
  void clear_is_brake_pedal_pressed();
  static const int kIsBrakePedalPressedFieldNumber = 1;
  bool is_brake_pedal_pressed() const;
  void set_is_brake_pedal_pressed(bool value);

  // optional bool is_brake_force_exist = 2;
  bool has_is_brake_force_exist() const;
  void clear_is_brake_force_exist();
  static const int kIsBrakeForceExistFieldNumber = 2;
  bool is_brake_force_exist() const;
  void set_is_brake_force_exist(bool value);

  // optional bool is_brake_over_heat = 3;
  bool has_is_brake_over_heat() const;
  void clear_is_brake_over_heat();
  static const int kIsBrakeOverHeatFieldNumber = 3;
  bool is_brake_over_heat() const;
  void set_is_brake_over_heat(bool value);

  // optional bool is_hand_brake_on = 4;
  bool has_is_hand_brake_on() const;
  void clear_is_hand_brake_on();
  static const int kIsHandBrakeOnFieldNumber = 4;
  bool is_hand_brake_on() const;
  void set_is_hand_brake_on(bool value);

  // optional bool is_brake_valid = 6;
  bool has_is_brake_valid() const;
  void clear_is_brake_valid();
  static const int kIsBrakeValidFieldNumber = 6;
  bool is_brake_valid() const;
  void set_is_brake_valid(bool value);

  // optional bool boo_input = 10;
  bool has_boo_input() const;
  void clear_boo_input();
  static const int kBooInputFieldNumber = 10;
  bool boo_input() const;
  void set_boo_input(bool value);

  // optional bool boo_cmd = 11;
  bool has_boo_cmd() const;
  void clear_boo_cmd();
  static const int kBooCmdFieldNumber = 11;
  bool boo_cmd() const;
  void set_boo_cmd(bool value);

  // optional bool boo_output = 12;
  bool has_boo_output() const;
  void clear_boo_output();
  static const int kBooOutputFieldNumber = 12;
  bool boo_output() const;
  void set_boo_output(bool value);

  // optional double brake_input = 7;
  bool has_brake_input() const;
  void clear_brake_input();
  static const int kBrakeInputFieldNumber = 7;
  double brake_input() const;
  void set_brake_input(double value);

  // optional double brake_cmd = 8;
  bool has_brake_cmd() const;
  void clear_brake_cmd();
  static const int kBrakeCmdFieldNumber = 8;
  double brake_cmd() const;
  void set_brake_cmd(double value);

  // optional double brake_output = 9;
  bool has_brake_output() const;
  void clear_brake_output();
  static const int kBrakeOutputFieldNumber = 9;
  double brake_output() const;
  void set_brake_output(double value);

  // optional int32 watchdog_source = 14;
  bool has_watchdog_source() const;
  void clear_watchdog_source();
  static const int kWatchdogSourceFieldNumber = 14;
  ::google::protobuf::int32 watchdog_source() const;
  void set_watchdog_source(::google::protobuf::int32 value);

  // optional bool watchdog_applying_brakes = 13;
  bool has_watchdog_applying_brakes() const;
  void clear_watchdog_applying_brakes();
  static const int kWatchdogApplyingBrakesFieldNumber = 13;
  bool watchdog_applying_brakes() const;
  void set_watchdog_applying_brakes(bool value);

  // optional bool brake_enabled = 15;
  bool has_brake_enabled() const;
  void clear_brake_enabled();
  static const int kBrakeEnabledFieldNumber = 15;
  bool brake_enabled() const;
  void set_brake_enabled(bool value);

  // optional bool driver_override = 16;
  bool has_driver_override() const;
  void clear_driver_override();
  static const int kDriverOverrideFieldNumber = 16;
  bool driver_override() const;
  void set_driver_override(bool value);

  // optional bool driver_activity = 17;
  bool has_driver_activity() const;
  void clear_driver_activity();
  static const int kDriverActivityFieldNumber = 17;
  bool driver_activity() const;
  void set_driver_activity(bool value);

  // optional bool watchdog_fault = 18;
  bool has_watchdog_fault() const;
  void clear_watchdog_fault();
  static const int kWatchdogFaultFieldNumber = 18;
  bool watchdog_fault() const;
  void set_watchdog_fault(bool value);

  // optional bool channel_1_fault = 19;
  bool has_channel_1_fault() const;
  void clear_channel_1_fault();
  static const int kChannel1FaultFieldNumber = 19;
  bool channel_1_fault() const;
  void set_channel_1_fault(bool value);

  // optional bool channel_2_fault = 20;
  bool has_channel_2_fault() const;
  void clear_channel_2_fault();
  static const int kChannel2FaultFieldNumber = 20;
  bool channel_2_fault() const;
  void set_channel_2_fault(bool value);

  // optional bool boo_fault = 21;
  bool has_boo_fault() const;
  void clear_boo_fault();
  static const int kBooFaultFieldNumber = 21;
  bool boo_fault() const;
  void set_boo_fault(bool value);

  // optional bool connector_fault = 22;
  bool has_connector_fault() const;
  void clear_connector_fault();
  static const int kConnectorFaultFieldNumber = 22;
  bool connector_fault() const;
  void set_connector_fault(bool value);

  // optional double brake_torque_req = 23;
  bool has_brake_torque_req() const;
  void clear_brake_torque_req();
  static const int kBrakeTorqueReqFieldNumber = 23;
  double brake_torque_req() const;
  void set_brake_torque_req(double value);

  // optional double brake_torque_act = 25;
  bool has_brake_torque_act() const;
  void clear_brake_torque_act();
  static const int kBrakeTorqueActFieldNumber = 25;
  double brake_torque_act() const;
  void set_brake_torque_act(double value);

  // optional .apollo.canbus.Brake.HSAStatusType hsa_status = 24;
  bool has_hsa_status() const;
  void clear_hsa_status();
  static const int kHsaStatusFieldNumber = 24;
  ::apollo::canbus::Brake_HSAStatusType hsa_status() const;
  void set_hsa_status(::apollo::canbus::Brake_HSAStatusType value);

  // optional .apollo.canbus.Brake.HSAModeType hsa_mode = 26;
  bool has_hsa_mode() const;
  void clear_hsa_mode();
  static const int kHsaModeFieldNumber = 26;
  ::apollo::canbus::Brake_HSAModeType hsa_mode() const;
  void set_hsa_mode(::apollo::canbus::Brake_HSAModeType value);

  // optional double wheel_torque_act = 27;
  bool has_wheel_torque_act() const;
  void clear_wheel_torque_act();
  static const int kWheelTorqueActFieldNumber = 27;
  double wheel_torque_act() const;
  void set_wheel_torque_act(double value);

  // optional int32 major_version = 28;
  bool has_major_version() const;
  void clear_major_version();
  static const int kMajorVersionFieldNumber = 28;
  ::google::protobuf::int32 major_version() const;
  void set_major_version(::google::protobuf::int32 value);

  // optional int32 minor_version = 29;
  bool has_minor_version() const;
  void clear_minor_version();
  static const int kMinorVersionFieldNumber = 29;
  ::google::protobuf::int32 minor_version() const;
  void set_minor_version(::google::protobuf::int32 value);

  // optional int32 build_number = 30;
  bool has_build_number() const;
  void clear_build_number();
  static const int kBuildNumberFieldNumber = 30;
  ::google::protobuf::int32 build_number() const;
  void set_build_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Brake)
 private:
  void set_has_is_brake_pedal_pressed();
  void clear_has_is_brake_pedal_pressed();
  void set_has_is_brake_force_exist();
  void clear_has_is_brake_force_exist();
  void set_has_is_brake_over_heat();
  void clear_has_is_brake_over_heat();
  void set_has_is_hand_brake_on();
  void clear_has_is_hand_brake_on();
  void set_has_brake_pedal_position();
  void clear_has_brake_pedal_position();
  void set_has_is_brake_valid();
  void clear_has_is_brake_valid();
  void set_has_brake_input();
  void clear_has_brake_input();
  void set_has_brake_cmd();
  void clear_has_brake_cmd();
  void set_has_brake_output();
  void clear_has_brake_output();
  void set_has_boo_input();
  void clear_has_boo_input();
  void set_has_boo_cmd();
  void clear_has_boo_cmd();
  void set_has_boo_output();
  void clear_has_boo_output();
  void set_has_watchdog_applying_brakes();
  void clear_has_watchdog_applying_brakes();
  void set_has_watchdog_source();
  void clear_has_watchdog_source();
  void set_has_brake_enabled();
  void clear_has_brake_enabled();
  void set_has_driver_override();
  void clear_has_driver_override();
  void set_has_driver_activity();
  void clear_has_driver_activity();
  void set_has_watchdog_fault();
  void clear_has_watchdog_fault();
  void set_has_channel_1_fault();
  void clear_has_channel_1_fault();
  void set_has_channel_2_fault();
  void clear_has_channel_2_fault();
  void set_has_boo_fault();
  void clear_has_boo_fault();
  void set_has_connector_fault();
  void clear_has_connector_fault();
  void set_has_brake_torque_req();
  void clear_has_brake_torque_req();
  void set_has_hsa_status();
  void clear_has_hsa_status();
  void set_has_brake_torque_act();
  void clear_has_brake_torque_act();
  void set_has_hsa_mode();
  void clear_has_hsa_mode();
  void set_has_wheel_torque_act();
  void clear_has_wheel_torque_act();
  void set_has_major_version();
  void clear_has_major_version();
  void set_has_minor_version();
  void clear_has_minor_version();
  void set_has_build_number();
  void clear_has_build_number();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double brake_pedal_position_;
  bool is_brake_pedal_pressed_;
  bool is_brake_force_exist_;
  bool is_brake_over_heat_;
  bool is_hand_brake_on_;
  bool is_brake_valid_;
  bool boo_input_;
  bool boo_cmd_;
  bool boo_output_;
  double brake_input_;
  double brake_cmd_;
  double brake_output_;
  ::google::protobuf::int32 watchdog_source_;
  bool watchdog_applying_brakes_;
  bool brake_enabled_;
  bool driver_override_;
  bool driver_activity_;
  bool watchdog_fault_;
  bool channel_1_fault_;
  bool channel_2_fault_;
  bool boo_fault_;
  bool connector_fault_;
  double brake_torque_req_;
  double brake_torque_act_;
  int hsa_status_;
  int hsa_mode_;
  double wheel_torque_act_;
  ::google::protobuf::int32 major_version_;
  ::google::protobuf::int32 minor_version_;
  ::google::protobuf::int32 build_number_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Epb : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Epb) */ {
 public:
  Epb();
  virtual ~Epb();

  Epb(const Epb& from);

  inline Epb& operator=(const Epb& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Epb& default_instance();

  static inline const Epb* internal_default_instance() {
    return reinterpret_cast<const Epb*>(
               &_Epb_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Epb* other);

  // implements Message ----------------------------------------------

  inline Epb* New() const PROTOBUF_FINAL { return New(NULL); }

  Epb* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Epb& from);
  void MergeFrom(const Epb& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Epb* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Epb_PBrakeType PBrakeType;
  static const PBrakeType PBRAKE_OFF =
    Epb_PBrakeType_PBRAKE_OFF;
  static const PBrakeType PBRAKE_TRANSITION =
    Epb_PBrakeType_PBRAKE_TRANSITION;
  static const PBrakeType PBRAKE_ON =
    Epb_PBrakeType_PBRAKE_ON;
  static const PBrakeType PBRAKE_FAULT =
    Epb_PBrakeType_PBRAKE_FAULT;
  static inline bool PBrakeType_IsValid(int value) {
    return Epb_PBrakeType_IsValid(value);
  }
  static const PBrakeType PBrakeType_MIN =
    Epb_PBrakeType_PBrakeType_MIN;
  static const PBrakeType PBrakeType_MAX =
    Epb_PBrakeType_PBrakeType_MAX;
  static const int PBrakeType_ARRAYSIZE =
    Epb_PBrakeType_PBrakeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PBrakeType_descriptor() {
    return Epb_PBrakeType_descriptor();
  }
  static inline const ::std::string& PBrakeType_Name(PBrakeType value) {
    return Epb_PBrakeType_Name(value);
  }
  static inline bool PBrakeType_Parse(const ::std::string& name,
      PBrakeType* value) {
    return Epb_PBrakeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bool is_epb_error = 1;
  bool has_is_epb_error() const;
  void clear_is_epb_error();
  static const int kIsEpbErrorFieldNumber = 1;
  bool is_epb_error() const;
  void set_is_epb_error(bool value);

  // optional bool is_epb_released = 2;
  bool has_is_epb_released() const;
  void clear_is_epb_released();
  static const int kIsEpbReleasedFieldNumber = 2;
  bool is_epb_released() const;
  void set_is_epb_released(bool value);

  // optional int32 epb_status = 3;
  bool has_epb_status() const;
  void clear_epb_status();
  static const int kEpbStatusFieldNumber = 3;
  ::google::protobuf::int32 epb_status() const;
  void set_epb_status(::google::protobuf::int32 value);

  // optional .apollo.canbus.Epb.PBrakeType parking_brake_status = 4;
  bool has_parking_brake_status() const;
  void clear_parking_brake_status();
  static const int kParkingBrakeStatusFieldNumber = 4;
  ::apollo::canbus::Epb_PBrakeType parking_brake_status() const;
  void set_parking_brake_status(::apollo::canbus::Epb_PBrakeType value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Epb)
 private:
  void set_has_is_epb_error();
  void clear_has_is_epb_error();
  void set_has_is_epb_released();
  void clear_has_is_epb_released();
  void set_has_epb_status();
  void clear_has_epb_status();
  void set_has_parking_brake_status();
  void clear_has_parking_brake_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool is_epb_error_;
  bool is_epb_released_;
  ::google::protobuf::int32 epb_status_;
  int parking_brake_status_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Gas : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Gas) */ {
 public:
  Gas();
  virtual ~Gas();

  Gas(const Gas& from);

  inline Gas& operator=(const Gas& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Gas& default_instance();

  static inline const Gas* internal_default_instance() {
    return reinterpret_cast<const Gas*>(
               &_Gas_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Gas* other);

  // implements Message ----------------------------------------------

  inline Gas* New() const PROTOBUF_FINAL { return New(NULL); }

  Gas* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Gas& from);
  void MergeFrom(const Gas& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Gas* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double gas_pedal_position = 3 [default = 0];
  bool has_gas_pedal_position() const;
  void clear_gas_pedal_position();
  static const int kGasPedalPositionFieldNumber = 3;
  double gas_pedal_position() const;
  void set_gas_pedal_position(double value);

  // optional bool is_gas_pedal_error = 1;
  bool has_is_gas_pedal_error() const;
  void clear_is_gas_pedal_error();
  static const int kIsGasPedalErrorFieldNumber = 1;
  bool is_gas_pedal_error() const;
  void set_is_gas_pedal_error(bool value);

  // optional bool is_gas_pedal_pressed_more = 2;
  bool has_is_gas_pedal_pressed_more() const;
  void clear_is_gas_pedal_pressed_more();
  static const int kIsGasPedalPressedMoreFieldNumber = 2;
  bool is_gas_pedal_pressed_more() const;
  void set_is_gas_pedal_pressed_more(bool value);

  // optional bool is_gas_valid = 4 [default = false];
  bool has_is_gas_valid() const;
  void clear_is_gas_valid();
  static const int kIsGasValidFieldNumber = 4;
  bool is_gas_valid() const;
  void set_is_gas_valid(bool value);

  // optional bool throttle_enabled = 9;
  bool has_throttle_enabled() const;
  void clear_throttle_enabled();
  static const int kThrottleEnabledFieldNumber = 9;
  bool throttle_enabled() const;
  void set_throttle_enabled(bool value);

  // optional int32 watchdog_source = 8;
  bool has_watchdog_source() const;
  void clear_watchdog_source();
  static const int kWatchdogSourceFieldNumber = 8;
  ::google::protobuf::int32 watchdog_source() const;
  void set_watchdog_source(::google::protobuf::int32 value);

  // optional double throttle_input = 5;
  bool has_throttle_input() const;
  void clear_throttle_input();
  static const int kThrottleInputFieldNumber = 5;
  double throttle_input() const;
  void set_throttle_input(double value);

  // optional double throttle_cmd = 6;
  bool has_throttle_cmd() const;
  void clear_throttle_cmd();
  static const int kThrottleCmdFieldNumber = 6;
  double throttle_cmd() const;
  void set_throttle_cmd(double value);

  // optional double throttle_output = 7;
  bool has_throttle_output() const;
  void clear_throttle_output();
  static const int kThrottleOutputFieldNumber = 7;
  double throttle_output() const;
  void set_throttle_output(double value);

  // optional bool driver_override = 10;
  bool has_driver_override() const;
  void clear_driver_override();
  static const int kDriverOverrideFieldNumber = 10;
  bool driver_override() const;
  void set_driver_override(bool value);

  // optional bool driver_activity = 11;
  bool has_driver_activity() const;
  void clear_driver_activity();
  static const int kDriverActivityFieldNumber = 11;
  bool driver_activity() const;
  void set_driver_activity(bool value);

  // optional bool watchdog_fault = 12;
  bool has_watchdog_fault() const;
  void clear_watchdog_fault();
  static const int kWatchdogFaultFieldNumber = 12;
  bool watchdog_fault() const;
  void set_watchdog_fault(bool value);

  // optional bool channel_1_fault = 13;
  bool has_channel_1_fault() const;
  void clear_channel_1_fault();
  static const int kChannel1FaultFieldNumber = 13;
  bool channel_1_fault() const;
  void set_channel_1_fault(bool value);

  // optional bool channel_2_fault = 14;
  bool has_channel_2_fault() const;
  void clear_channel_2_fault();
  static const int kChannel2FaultFieldNumber = 14;
  bool channel_2_fault() const;
  void set_channel_2_fault(bool value);

  // optional bool connector_fault = 15;
  bool has_connector_fault() const;
  void clear_connector_fault();
  static const int kConnectorFaultFieldNumber = 15;
  bool connector_fault() const;
  void set_connector_fault(bool value);

  // optional double accelerator_pedal = 16;
  bool has_accelerator_pedal() const;
  void clear_accelerator_pedal();
  static const int kAcceleratorPedalFieldNumber = 16;
  double accelerator_pedal() const;
  void set_accelerator_pedal(double value);

  // optional double accelerator_pedal_rate = 17;
  bool has_accelerator_pedal_rate() const;
  void clear_accelerator_pedal_rate();
  static const int kAcceleratorPedalRateFieldNumber = 17;
  double accelerator_pedal_rate() const;
  void set_accelerator_pedal_rate(double value);

  // optional int32 major_version = 18;
  bool has_major_version() const;
  void clear_major_version();
  static const int kMajorVersionFieldNumber = 18;
  ::google::protobuf::int32 major_version() const;
  void set_major_version(::google::protobuf::int32 value);

  // optional int32 minor_version = 19;
  bool has_minor_version() const;
  void clear_minor_version();
  static const int kMinorVersionFieldNumber = 19;
  ::google::protobuf::int32 minor_version() const;
  void set_minor_version(::google::protobuf::int32 value);

  // optional int32 build_number = 20;
  bool has_build_number() const;
  void clear_build_number();
  static const int kBuildNumberFieldNumber = 20;
  ::google::protobuf::int32 build_number() const;
  void set_build_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Gas)
 private:
  void set_has_is_gas_pedal_error();
  void clear_has_is_gas_pedal_error();
  void set_has_is_gas_pedal_pressed_more();
  void clear_has_is_gas_pedal_pressed_more();
  void set_has_gas_pedal_position();
  void clear_has_gas_pedal_position();
  void set_has_is_gas_valid();
  void clear_has_is_gas_valid();
  void set_has_throttle_input();
  void clear_has_throttle_input();
  void set_has_throttle_cmd();
  void clear_has_throttle_cmd();
  void set_has_throttle_output();
  void clear_has_throttle_output();
  void set_has_watchdog_source();
  void clear_has_watchdog_source();
  void set_has_throttle_enabled();
  void clear_has_throttle_enabled();
  void set_has_driver_override();
  void clear_has_driver_override();
  void set_has_driver_activity();
  void clear_has_driver_activity();
  void set_has_watchdog_fault();
  void clear_has_watchdog_fault();
  void set_has_channel_1_fault();
  void clear_has_channel_1_fault();
  void set_has_channel_2_fault();
  void clear_has_channel_2_fault();
  void set_has_connector_fault();
  void clear_has_connector_fault();
  void set_has_accelerator_pedal();
  void clear_has_accelerator_pedal();
  void set_has_accelerator_pedal_rate();
  void clear_has_accelerator_pedal_rate();
  void set_has_major_version();
  void clear_has_major_version();
  void set_has_minor_version();
  void clear_has_minor_version();
  void set_has_build_number();
  void clear_has_build_number();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double gas_pedal_position_;
  bool is_gas_pedal_error_;
  bool is_gas_pedal_pressed_more_;
  bool is_gas_valid_;
  bool throttle_enabled_;
  ::google::protobuf::int32 watchdog_source_;
  double throttle_input_;
  double throttle_cmd_;
  double throttle_output_;
  bool driver_override_;
  bool driver_activity_;
  bool watchdog_fault_;
  bool channel_1_fault_;
  bool channel_2_fault_;
  bool connector_fault_;
  double accelerator_pedal_;
  double accelerator_pedal_rate_;
  ::google::protobuf::int32 major_version_;
  ::google::protobuf::int32 minor_version_;
  ::google::protobuf::int32 build_number_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Esp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Esp) */ {
 public:
  Esp();
  virtual ~Esp();

  Esp(const Esp& from);

  inline Esp& operator=(const Esp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Esp& default_instance();

  static inline const Esp* internal_default_instance() {
    return reinterpret_cast<const Esp*>(
               &_Esp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Esp* other);

  // implements Message ----------------------------------------------

  inline Esp* New() const PROTOBUF_FINAL { return New(NULL); }

  Esp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Esp& from);
  void MergeFrom(const Esp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Esp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_esp_acc_error = 1;
  bool has_is_esp_acc_error() const;
  void clear_is_esp_acc_error();
  static const int kIsEspAccErrorFieldNumber = 1;
  bool is_esp_acc_error() const;
  void set_is_esp_acc_error(bool value);

  // optional bool is_esp_on = 2;
  bool has_is_esp_on() const;
  void clear_is_esp_on();
  static const int kIsEspOnFieldNumber = 2;
  bool is_esp_on() const;
  void set_is_esp_on(bool value);

  // optional bool is_esp_active = 3;
  bool has_is_esp_active() const;
  void clear_is_esp_active();
  static const int kIsEspActiveFieldNumber = 3;
  bool is_esp_active() const;
  void set_is_esp_active(bool value);

  // optional bool is_abs_error = 4;
  bool has_is_abs_error() const;
  void clear_is_abs_error();
  static const int kIsAbsErrorFieldNumber = 4;
  bool is_abs_error() const;
  void set_is_abs_error(bool value);

  // optional bool is_abs_active = 5;
  bool has_is_abs_active() const;
  void clear_is_abs_active();
  static const int kIsAbsActiveFieldNumber = 5;
  bool is_abs_active() const;
  void set_is_abs_active(bool value);

  // optional bool is_tcsvdc_fail = 6;
  bool has_is_tcsvdc_fail() const;
  void clear_is_tcsvdc_fail();
  static const int kIsTcsvdcFailFieldNumber = 6;
  bool is_tcsvdc_fail() const;
  void set_is_tcsvdc_fail(bool value);

  // optional bool is_abs_enabled = 7;
  bool has_is_abs_enabled() const;
  void clear_is_abs_enabled();
  static const int kIsAbsEnabledFieldNumber = 7;
  bool is_abs_enabled() const;
  void set_is_abs_enabled(bool value);

  // optional bool is_stab_active = 8;
  bool has_is_stab_active() const;
  void clear_is_stab_active();
  static const int kIsStabActiveFieldNumber = 8;
  bool is_stab_active() const;
  void set_is_stab_active(bool value);

  // optional bool is_stab_enabled = 9;
  bool has_is_stab_enabled() const;
  void clear_is_stab_enabled();
  static const int kIsStabEnabledFieldNumber = 9;
  bool is_stab_enabled() const;
  void set_is_stab_enabled(bool value);

  // optional bool is_trac_active = 10;
  bool has_is_trac_active() const;
  void clear_is_trac_active();
  static const int kIsTracActiveFieldNumber = 10;
  bool is_trac_active() const;
  void set_is_trac_active(bool value);

  // optional bool is_trac_enabled = 11;
  bool has_is_trac_enabled() const;
  void clear_is_trac_enabled();
  static const int kIsTracEnabledFieldNumber = 11;
  bool is_trac_enabled() const;
  void set_is_trac_enabled(bool value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Esp)
 private:
  void set_has_is_esp_acc_error();
  void clear_has_is_esp_acc_error();
  void set_has_is_esp_on();
  void clear_has_is_esp_on();
  void set_has_is_esp_active();
  void clear_has_is_esp_active();
  void set_has_is_abs_error();
  void clear_has_is_abs_error();
  void set_has_is_abs_active();
  void clear_has_is_abs_active();
  void set_has_is_tcsvdc_fail();
  void clear_has_is_tcsvdc_fail();
  void set_has_is_abs_enabled();
  void clear_has_is_abs_enabled();
  void set_has_is_stab_active();
  void clear_has_is_stab_active();
  void set_has_is_stab_enabled();
  void clear_has_is_stab_enabled();
  void set_has_is_trac_active();
  void clear_has_is_trac_active();
  void set_has_is_trac_enabled();
  void clear_has_is_trac_enabled();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool is_esp_acc_error_;
  bool is_esp_on_;
  bool is_esp_active_;
  bool is_abs_error_;
  bool is_abs_active_;
  bool is_tcsvdc_fail_;
  bool is_abs_enabled_;
  bool is_stab_active_;
  bool is_stab_enabled_;
  bool is_trac_active_;
  bool is_trac_enabled_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ems : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Ems) */ {
 public:
  Ems();
  virtual ~Ems();

  Ems(const Ems& from);

  inline Ems& operator=(const Ems& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ems& default_instance();

  static inline const Ems* internal_default_instance() {
    return reinterpret_cast<const Ems*>(
               &_Ems_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Ems* other);

  // implements Message ----------------------------------------------

  inline Ems* New() const PROTOBUF_FINAL { return New(NULL); }

  Ems* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Ems& from);
  void MergeFrom(const Ems& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Ems* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Ems_Type Type;
  static const Type STOP =
    Ems_Type_STOP;
  static const Type CRANK =
    Ems_Type_CRANK;
  static const Type RUNNING =
    Ems_Type_RUNNING;
  static const Type INVALID =
    Ems_Type_INVALID;
  static inline bool Type_IsValid(int value) {
    return Ems_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Ems_Type_Type_MIN;
  static const Type Type_MAX =
    Ems_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Ems_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Ems_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Ems_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Ems_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double max_engine_torq_percent = 4;
  bool has_max_engine_torq_percent() const;
  void clear_max_engine_torq_percent();
  static const int kMaxEngineTorqPercentFieldNumber = 4;
  double max_engine_torq_percent() const;
  void set_max_engine_torq_percent(double value);

  // optional .apollo.canbus.Ems.Type engine_state = 3;
  bool has_engine_state() const;
  void clear_engine_state();
  static const int kEngineStateFieldNumber = 3;
  ::apollo::canbus::Ems_Type engine_state() const;
  void set_engine_state(::apollo::canbus::Ems_Type value);

  // optional bool is_engine_acc_available = 1;
  bool has_is_engine_acc_available() const;
  void clear_is_engine_acc_available();
  static const int kIsEngineAccAvailableFieldNumber = 1;
  bool is_engine_acc_available() const;
  void set_is_engine_acc_available(bool value);

  // optional bool is_engine_acc_error = 2;
  bool has_is_engine_acc_error() const;
  void clear_is_engine_acc_error();
  static const int kIsEngineAccErrorFieldNumber = 2;
  bool is_engine_acc_error() const;
  void set_is_engine_acc_error(bool value);

  // optional bool is_engine_speed_error = 7;
  bool has_is_engine_speed_error() const;
  void clear_is_engine_speed_error();
  static const int kIsEngineSpeedErrorFieldNumber = 7;
  bool is_engine_speed_error() const;
  void set_is_engine_speed_error(bool value);

  // optional bool is_over_engine_torque = 10;
  bool has_is_over_engine_torque() const;
  void clear_is_over_engine_torque();
  static const int kIsOverEngineTorqueFieldNumber = 10;
  bool is_over_engine_torque() const;
  void set_is_over_engine_torque(bool value);

  // optional double min_engine_torq_percent = 5;
  bool has_min_engine_torq_percent() const;
  void clear_min_engine_torq_percent();
  static const int kMinEngineTorqPercentFieldNumber = 5;
  double min_engine_torq_percent() const;
  void set_min_engine_torq_percent(double value);

  // optional int32 base_engine_torq_constant = 6;
  bool has_base_engine_torq_constant() const;
  void clear_base_engine_torq_constant();
  static const int kBaseEngineTorqConstantFieldNumber = 6;
  ::google::protobuf::int32 base_engine_torq_constant() const;
  void set_base_engine_torq_constant(::google::protobuf::int32 value);

  // optional int32 engine_torque = 9;
  bool has_engine_torque() const;
  void clear_engine_torque();
  static const int kEngineTorqueFieldNumber = 9;
  ::google::protobuf::int32 engine_torque() const;
  void set_engine_torque(::google::protobuf::int32 value);

  // optional double engine_speed = 8;
  bool has_engine_speed() const;
  void clear_engine_speed();
  static const int kEngineSpeedFieldNumber = 8;
  double engine_speed() const;
  void set_engine_speed(double value);

  // optional double engine_rpm = 11;
  bool has_engine_rpm() const;
  void clear_engine_rpm();
  static const int kEngineRpmFieldNumber = 11;
  double engine_rpm() const;
  void set_engine_rpm(double value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Ems)
 private:
  void set_has_is_engine_acc_available();
  void clear_has_is_engine_acc_available();
  void set_has_is_engine_acc_error();
  void clear_has_is_engine_acc_error();
  void set_has_engine_state();
  void clear_has_engine_state();
  void set_has_max_engine_torq_percent();
  void clear_has_max_engine_torq_percent();
  void set_has_min_engine_torq_percent();
  void clear_has_min_engine_torq_percent();
  void set_has_base_engine_torq_constant();
  void clear_has_base_engine_torq_constant();
  void set_has_is_engine_speed_error();
  void clear_has_is_engine_speed_error();
  void set_has_engine_speed();
  void clear_has_engine_speed();
  void set_has_engine_torque();
  void clear_has_engine_torque();
  void set_has_is_over_engine_torque();
  void clear_has_is_over_engine_torque();
  void set_has_engine_rpm();
  void clear_has_engine_rpm();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double max_engine_torq_percent_;
  int engine_state_;
  bool is_engine_acc_available_;
  bool is_engine_acc_error_;
  bool is_engine_speed_error_;
  bool is_over_engine_torque_;
  double min_engine_torq_percent_;
  ::google::protobuf::int32 base_engine_torq_constant_;
  ::google::protobuf::int32 engine_torque_;
  double engine_speed_;
  double engine_rpm_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Gear : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Gear) */ {
 public:
  Gear();
  virtual ~Gear();

  Gear(const Gear& from);

  inline Gear& operator=(const Gear& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Gear& default_instance();

  static inline const Gear* internal_default_instance() {
    return reinterpret_cast<const Gear*>(
               &_Gear_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(Gear* other);

  // implements Message ----------------------------------------------

  inline Gear* New() const PROTOBUF_FINAL { return New(NULL); }

  Gear* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Gear& from);
  void MergeFrom(const Gear& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Gear* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.canbus.Chassis.GearPosition gear_state = 2;
  bool has_gear_state() const;
  void clear_gear_state();
  static const int kGearStateFieldNumber = 2;
  ::apollo::canbus::Chassis_GearPosition gear_state() const;
  void set_gear_state(::apollo::canbus::Chassis_GearPosition value);

  // optional bool is_shift_position_valid = 1;
  bool has_is_shift_position_valid() const;
  void clear_is_shift_position_valid();
  static const int kIsShiftPositionValidFieldNumber = 1;
  bool is_shift_position_valid() const;
  void set_is_shift_position_valid(bool value);

  // optional bool driver_override = 3;
  bool has_driver_override() const;
  void clear_driver_override();
  static const int kDriverOverrideFieldNumber = 3;
  bool driver_override() const;
  void set_driver_override(bool value);

  // optional bool canbus_fault = 5;
  bool has_canbus_fault() const;
  void clear_canbus_fault();
  static const int kCanbusFaultFieldNumber = 5;
  bool canbus_fault() const;
  void set_canbus_fault(bool value);

  // optional .apollo.canbus.Chassis.GearPosition gear_cmd = 4;
  bool has_gear_cmd() const;
  void clear_gear_cmd();
  static const int kGearCmdFieldNumber = 4;
  ::apollo::canbus::Chassis_GearPosition gear_cmd() const;
  void set_gear_cmd(::apollo::canbus::Chassis_GearPosition value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Gear)
 private:
  void set_has_is_shift_position_valid();
  void clear_has_is_shift_position_valid();
  void set_has_gear_state();
  void clear_has_gear_state();
  void set_has_driver_override();
  void clear_has_driver_override();
  void set_has_gear_cmd();
  void clear_has_gear_cmd();
  void set_has_canbus_fault();
  void clear_has_canbus_fault();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int gear_state_;
  bool is_shift_position_valid_;
  bool driver_override_;
  bool canbus_fault_;
  int gear_cmd_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Safety : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Safety) */ {
 public:
  Safety();
  virtual ~Safety();

  Safety(const Safety& from);

  inline Safety& operator=(const Safety& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Safety& default_instance();

  static inline const Safety* internal_default_instance() {
    return reinterpret_cast<const Safety*>(
               &_Safety_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(Safety* other);

  // implements Message ----------------------------------------------

  inline Safety* New() const PROTOBUF_FINAL { return New(NULL); }

  Safety* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Safety& from);
  void MergeFrom(const Safety& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Safety* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 emergency_button = 3;
  bool has_emergency_button() const;
  void clear_emergency_button();
  static const int kEmergencyButtonFieldNumber = 3;
  ::google::protobuf::int32 emergency_button() const;
  void set_emergency_button(::google::protobuf::int32 value);

  // optional bool is_driver_car_door_close = 1;
  bool has_is_driver_car_door_close() const;
  void clear_is_driver_car_door_close();
  static const int kIsDriverCarDoorCloseFieldNumber = 1;
  bool is_driver_car_door_close() const;
  void set_is_driver_car_door_close(bool value);

  // optional bool is_driver_buckled = 2;
  bool has_is_driver_buckled() const;
  void clear_is_driver_buckled();
  static const int kIsDriverBuckledFieldNumber = 2;
  bool is_driver_buckled() const;
  void set_is_driver_buckled(bool value);

  // optional bool has_error = 4 [default = false];
  bool has_has_error() const;
  void clear_has_error();
  static const int kHasErrorFieldNumber = 4;
  bool has_error() const;
  void set_has_error(bool value);

  // optional bool is_motor_invertor_fault = 5;
  bool has_is_motor_invertor_fault() const;
  void clear_is_motor_invertor_fault();
  static const int kIsMotorInvertorFaultFieldNumber = 5;
  bool is_motor_invertor_fault() const;
  void set_is_motor_invertor_fault(bool value);

  // optional bool is_system_fault = 6;
  bool has_is_system_fault() const;
  void clear_is_system_fault();
  static const int kIsSystemFaultFieldNumber = 6;
  bool is_system_fault() const;
  void set_is_system_fault(bool value);

  // optional bool is_power_battery_fault = 7;
  bool has_is_power_battery_fault() const;
  void clear_is_power_battery_fault();
  static const int kIsPowerBatteryFaultFieldNumber = 7;
  bool is_power_battery_fault() const;
  void set_is_power_battery_fault(bool value);

  // optional bool is_motor_invertor_over_temperature = 8;
  bool has_is_motor_invertor_over_temperature() const;
  void clear_is_motor_invertor_over_temperature();
  static const int kIsMotorInvertorOverTemperatureFieldNumber = 8;
  bool is_motor_invertor_over_temperature() const;
  void set_is_motor_invertor_over_temperature(bool value);

  // optional bool is_small_battery_charge_discharge_fault = 9;
  bool has_is_small_battery_charge_discharge_fault() const;
  void clear_is_small_battery_charge_discharge_fault();
  static const int kIsSmallBatteryChargeDischargeFaultFieldNumber = 9;
  bool is_small_battery_charge_discharge_fault() const;
  void set_is_small_battery_charge_discharge_fault(bool value);

  // optional int32 driving_mode = 10;
  bool has_driving_mode() const;
  void clear_driving_mode();
  static const int kDrivingModeFieldNumber = 10;
  ::google::protobuf::int32 driving_mode() const;
  void set_driving_mode(::google::protobuf::int32 value);

  // optional bool is_passenger_door_open = 11;
  bool has_is_passenger_door_open() const;
  void clear_is_passenger_door_open();
  static const int kIsPassengerDoorOpenFieldNumber = 11;
  bool is_passenger_door_open() const;
  void set_is_passenger_door_open(bool value);

  // optional bool is_rearleft_door_open = 12;
  bool has_is_rearleft_door_open() const;
  void clear_is_rearleft_door_open();
  static const int kIsRearleftDoorOpenFieldNumber = 12;
  bool is_rearleft_door_open() const;
  void set_is_rearleft_door_open(bool value);

  // optional bool is_rearright_door_open = 13;
  bool has_is_rearright_door_open() const;
  void clear_is_rearright_door_open();
  static const int kIsRearrightDoorOpenFieldNumber = 13;
  bool is_rearright_door_open() const;
  void set_is_rearright_door_open(bool value);

  // optional bool is_hood_open = 14;
  bool has_is_hood_open() const;
  void clear_is_hood_open();
  static const int kIsHoodOpenFieldNumber = 14;
  bool is_hood_open() const;
  void set_is_hood_open(bool value);

  // optional bool is_trunk_open = 15;
  bool has_is_trunk_open() const;
  void clear_is_trunk_open();
  static const int kIsTrunkOpenFieldNumber = 15;
  bool is_trunk_open() const;
  void set_is_trunk_open(bool value);

  // optional bool is_passenger_detected = 16;
  bool has_is_passenger_detected() const;
  void clear_is_passenger_detected();
  static const int kIsPassengerDetectedFieldNumber = 16;
  bool is_passenger_detected() const;
  void set_is_passenger_detected(bool value);

  // optional bool is_passenger_airbag_enabled = 17;
  bool has_is_passenger_airbag_enabled() const;
  void clear_is_passenger_airbag_enabled();
  static const int kIsPassengerAirbagEnabledFieldNumber = 17;
  bool is_passenger_airbag_enabled() const;
  void set_is_passenger_airbag_enabled(bool value);

  // optional bool is_passenger_buckled = 18;
  bool has_is_passenger_buckled() const;
  void clear_is_passenger_buckled();
  static const int kIsPassengerBuckledFieldNumber = 18;
  bool is_passenger_buckled() const;
  void set_is_passenger_buckled(bool value);

  // optional int32 front_left_tire_press = 19;
  bool has_front_left_tire_press() const;
  void clear_front_left_tire_press();
  static const int kFrontLeftTirePressFieldNumber = 19;
  ::google::protobuf::int32 front_left_tire_press() const;
  void set_front_left_tire_press(::google::protobuf::int32 value);

  // optional int32 front_right_tire_press = 20;
  bool has_front_right_tire_press() const;
  void clear_front_right_tire_press();
  static const int kFrontRightTirePressFieldNumber = 20;
  ::google::protobuf::int32 front_right_tire_press() const;
  void set_front_right_tire_press(::google::protobuf::int32 value);

  // optional int32 rear_left_tire_press = 21;
  bool has_rear_left_tire_press() const;
  void clear_rear_left_tire_press();
  static const int kRearLeftTirePressFieldNumber = 21;
  ::google::protobuf::int32 rear_left_tire_press() const;
  void set_rear_left_tire_press(::google::protobuf::int32 value);

  // optional int32 rear_right_tire_press = 22;
  bool has_rear_right_tire_press() const;
  void clear_rear_right_tire_press();
  static const int kRearRightTirePressFieldNumber = 22;
  ::google::protobuf::int32 rear_right_tire_press() const;
  void set_rear_right_tire_press(::google::protobuf::int32 value);

  // optional .apollo.canbus.Chassis.DrivingMode car_driving_mode = 23;
  bool has_car_driving_mode() const;
  void clear_car_driving_mode();
  static const int kCarDrivingModeFieldNumber = 23;
  ::apollo::canbus::Chassis_DrivingMode car_driving_mode() const;
  void set_car_driving_mode(::apollo::canbus::Chassis_DrivingMode value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Safety)
 private:
  void set_has_is_driver_car_door_close();
  void clear_has_is_driver_car_door_close();
  void set_has_is_driver_buckled();
  void clear_has_is_driver_buckled();
  void set_has_emergency_button();
  void clear_has_emergency_button();
  void set_has_has_error();
  void clear_has_has_error();
  void set_has_is_motor_invertor_fault();
  void clear_has_is_motor_invertor_fault();
  void set_has_is_system_fault();
  void clear_has_is_system_fault();
  void set_has_is_power_battery_fault();
  void clear_has_is_power_battery_fault();
  void set_has_is_motor_invertor_over_temperature();
  void clear_has_is_motor_invertor_over_temperature();
  void set_has_is_small_battery_charge_discharge_fault();
  void clear_has_is_small_battery_charge_discharge_fault();
  void set_has_driving_mode();
  void clear_has_driving_mode();
  void set_has_is_passenger_door_open();
  void clear_has_is_passenger_door_open();
  void set_has_is_rearleft_door_open();
  void clear_has_is_rearleft_door_open();
  void set_has_is_rearright_door_open();
  void clear_has_is_rearright_door_open();
  void set_has_is_hood_open();
  void clear_has_is_hood_open();
  void set_has_is_trunk_open();
  void clear_has_is_trunk_open();
  void set_has_is_passenger_detected();
  void clear_has_is_passenger_detected();
  void set_has_is_passenger_airbag_enabled();
  void clear_has_is_passenger_airbag_enabled();
  void set_has_is_passenger_buckled();
  void clear_has_is_passenger_buckled();
  void set_has_front_left_tire_press();
  void clear_has_front_left_tire_press();
  void set_has_front_right_tire_press();
  void clear_has_front_right_tire_press();
  void set_has_rear_left_tire_press();
  void clear_has_rear_left_tire_press();
  void set_has_rear_right_tire_press();
  void clear_has_rear_right_tire_press();
  void set_has_car_driving_mode();
  void clear_has_car_driving_mode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 emergency_button_;
  bool is_driver_car_door_close_;
  bool is_driver_buckled_;
  bool has_error_;
  bool is_motor_invertor_fault_;
  bool is_system_fault_;
  bool is_power_battery_fault_;
  bool is_motor_invertor_over_temperature_;
  bool is_small_battery_charge_discharge_fault_;
  ::google::protobuf::int32 driving_mode_;
  bool is_passenger_door_open_;
  bool is_rearleft_door_open_;
  bool is_rearright_door_open_;
  bool is_hood_open_;
  bool is_trunk_open_;
  bool is_passenger_detected_;
  bool is_passenger_airbag_enabled_;
  bool is_passenger_buckled_;
  ::google::protobuf::int32 front_left_tire_press_;
  ::google::protobuf::int32 front_right_tire_press_;
  ::google::protobuf::int32 rear_left_tire_press_;
  ::google::protobuf::int32 rear_right_tire_press_;
  int car_driving_mode_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BasicInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.BasicInfo) */ {
 public:
  BasicInfo();
  virtual ~BasicInfo();

  BasicInfo(const BasicInfo& from);

  inline BasicInfo& operator=(const BasicInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BasicInfo& default_instance();

  static inline const BasicInfo* internal_default_instance() {
    return reinterpret_cast<const BasicInfo*>(
               &_BasicInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(BasicInfo* other);

  // implements Message ----------------------------------------------

  inline BasicInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  BasicInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BasicInfo& from);
  void MergeFrom(const BasicInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BasicInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef BasicInfo_Type Type;
  static const Type OFF =
    BasicInfo_Type_OFF;
  static const Type ACC =
    BasicInfo_Type_ACC;
  static const Type ON =
    BasicInfo_Type_ON;
  static const Type START =
    BasicInfo_Type_START;
  static const Type INVALID =
    BasicInfo_Type_INVALID;
  static inline bool Type_IsValid(int value) {
    return BasicInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    BasicInfo_Type_Type_MIN;
  static const Type Type_MAX =
    BasicInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    BasicInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return BasicInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return BasicInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return BasicInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .apollo.canbus.BasicInfo.Type power_state = 2;
  bool has_power_state() const;
  void clear_power_state();
  static const int kPowerStateFieldNumber = 2;
  ::apollo::canbus::BasicInfo_Type power_state() const;
  void set_power_state(::apollo::canbus::BasicInfo_Type value);

  // optional bool is_auto_mode = 1;
  bool has_is_auto_mode() const;
  void clear_is_auto_mode();
  static const int kIsAutoModeFieldNumber = 1;
  bool is_auto_mode() const;
  void set_is_auto_mode(bool value);

  // optional bool is_air_bag_deployed = 3;
  bool has_is_air_bag_deployed() const;
  void clear_is_air_bag_deployed();
  static const int kIsAirBagDeployedFieldNumber = 3;
  bool is_air_bag_deployed() const;
  void set_is_air_bag_deployed(bool value);

  // optional bool is_system_error = 6;
  bool has_is_system_error() const;
  void clear_is_system_error();
  static const int kIsSystemErrorFieldNumber = 6;
  bool is_system_error() const;
  void set_is_system_error(bool value);

  // optional bool is_human_interrupt = 7;
  bool has_is_human_interrupt() const;
  void clear_is_human_interrupt();
  static const int kIsHumanInterruptFieldNumber = 7;
  bool is_human_interrupt() const;
  void set_is_human_interrupt(bool value);

  // optional double odo_meter = 4;
  bool has_odo_meter() const;
  void clear_odo_meter();
  static const int kOdoMeterFieldNumber = 4;
  double odo_meter() const;
  void set_odo_meter(double value);

  // optional double drive_range = 5;
  bool has_drive_range() const;
  void clear_drive_range();
  static const int kDriveRangeFieldNumber = 5;
  double drive_range() const;
  void set_drive_range(double value);

  // optional bool acc_on_button = 8;
  bool has_acc_on_button() const;
  void clear_acc_on_button();
  static const int kAccOnButtonFieldNumber = 8;
  bool acc_on_button() const;
  void set_acc_on_button(bool value);

  // optional bool acc_off_button = 9;
  bool has_acc_off_button() const;
  void clear_acc_off_button();
  static const int kAccOffButtonFieldNumber = 9;
  bool acc_off_button() const;
  void set_acc_off_button(bool value);

  // optional bool acc_res_button = 10;
  bool has_acc_res_button() const;
  void clear_acc_res_button();
  static const int kAccResButtonFieldNumber = 10;
  bool acc_res_button() const;
  void set_acc_res_button(bool value);

  // optional bool acc_cancel_button = 11;
  bool has_acc_cancel_button() const;
  void clear_acc_cancel_button();
  static const int kAccCancelButtonFieldNumber = 11;
  bool acc_cancel_button() const;
  void set_acc_cancel_button(bool value);

  // optional bool acc_on_off_button = 12;
  bool has_acc_on_off_button() const;
  void clear_acc_on_off_button();
  static const int kAccOnOffButtonFieldNumber = 12;
  bool acc_on_off_button() const;
  void set_acc_on_off_button(bool value);

  // optional bool acc_res_cancel_button = 13;
  bool has_acc_res_cancel_button() const;
  void clear_acc_res_cancel_button();
  static const int kAccResCancelButtonFieldNumber = 13;
  bool acc_res_cancel_button() const;
  void set_acc_res_cancel_button(bool value);

  // optional bool acc_inc_spd_button = 14;
  bool has_acc_inc_spd_button() const;
  void clear_acc_inc_spd_button();
  static const int kAccIncSpdButtonFieldNumber = 14;
  bool acc_inc_spd_button() const;
  void set_acc_inc_spd_button(bool value);

  // optional bool acc_dec_spd_button = 15;
  bool has_acc_dec_spd_button() const;
  void clear_acc_dec_spd_button();
  static const int kAccDecSpdButtonFieldNumber = 15;
  bool acc_dec_spd_button() const;
  void set_acc_dec_spd_button(bool value);

  // optional bool acc_inc_gap_button = 16;
  bool has_acc_inc_gap_button() const;
  void clear_acc_inc_gap_button();
  static const int kAccIncGapButtonFieldNumber = 16;
  bool acc_inc_gap_button() const;
  void set_acc_inc_gap_button(bool value);

  // optional bool acc_dec_gap_button = 17;
  bool has_acc_dec_gap_button() const;
  void clear_acc_dec_gap_button();
  static const int kAccDecGapButtonFieldNumber = 17;
  bool acc_dec_gap_button() const;
  void set_acc_dec_gap_button(bool value);

  // optional bool lka_button = 18;
  bool has_lka_button() const;
  void clear_lka_button();
  static const int kLkaButtonFieldNumber = 18;
  bool lka_button() const;
  void set_lka_button(bool value);

  // optional bool canbus_fault = 19;
  bool has_canbus_fault() const;
  void clear_canbus_fault();
  static const int kCanbusFaultFieldNumber = 19;
  bool canbus_fault() const;
  void set_canbus_fault(bool value);

  // optional int32 year = 23;
  bool has_year() const;
  void clear_year();
  static const int kYearFieldNumber = 23;
  ::google::protobuf::int32 year() const;
  void set_year(::google::protobuf::int32 value);

  // optional double latitude = 20;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 20;
  double latitude() const;
  void set_latitude(double value);

  // optional double longitude = 21;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 21;
  double longitude() const;
  void set_longitude(double value);

  // optional int32 month = 24;
  bool has_month() const;
  void clear_month();
  static const int kMonthFieldNumber = 24;
  ::google::protobuf::int32 month() const;
  void set_month(::google::protobuf::int32 value);

  // optional int32 day = 25;
  bool has_day() const;
  void clear_day();
  static const int kDayFieldNumber = 25;
  ::google::protobuf::int32 day() const;
  void set_day(::google::protobuf::int32 value);

  // optional int32 hours = 26;
  bool has_hours() const;
  void clear_hours();
  static const int kHoursFieldNumber = 26;
  ::google::protobuf::int32 hours() const;
  void set_hours(::google::protobuf::int32 value);

  // optional int32 minutes = 27;
  bool has_minutes() const;
  void clear_minutes();
  static const int kMinutesFieldNumber = 27;
  ::google::protobuf::int32 minutes() const;
  void set_minutes(::google::protobuf::int32 value);

  // optional int32 seconds = 28;
  bool has_seconds() const;
  void clear_seconds();
  static const int kSecondsFieldNumber = 28;
  ::google::protobuf::int32 seconds() const;
  void set_seconds(::google::protobuf::int32 value);

  // optional bool gps_valid = 22;
  bool has_gps_valid() const;
  void clear_gps_valid();
  static const int kGpsValidFieldNumber = 22;
  bool gps_valid() const;
  void set_gps_valid(bool value);

  // optional bool is_gps_fault = 31;
  bool has_is_gps_fault() const;
  void clear_is_gps_fault();
  static const int kIsGpsFaultFieldNumber = 31;
  bool is_gps_fault() const;
  void set_is_gps_fault(bool value);

  // optional bool is_inferred = 32;
  bool has_is_inferred() const;
  void clear_is_inferred();
  static const int kIsInferredFieldNumber = 32;
  bool is_inferred() const;
  void set_is_inferred(bool value);

  // optional double compass_direction = 29;
  bool has_compass_direction() const;
  void clear_compass_direction();
  static const int kCompassDirectionFieldNumber = 29;
  double compass_direction() const;
  void set_compass_direction(double value);

  // optional double pdop = 30;
  bool has_pdop() const;
  void clear_pdop();
  static const int kPdopFieldNumber = 30;
  double pdop() const;
  void set_pdop(double value);

  // optional double altitude = 33;
  bool has_altitude() const;
  void clear_altitude();
  static const int kAltitudeFieldNumber = 33;
  double altitude() const;
  void set_altitude(double value);

  // optional double heading = 34;
  bool has_heading() const;
  void clear_heading();
  static const int kHeadingFieldNumber = 34;
  double heading() const;
  void set_heading(double value);

  // optional double hdop = 35;
  bool has_hdop() const;
  void clear_hdop();
  static const int kHdopFieldNumber = 35;
  double hdop() const;
  void set_hdop(double value);

  // optional double vdop = 36;
  bool has_vdop() const;
  void clear_vdop();
  static const int kVdopFieldNumber = 36;
  double vdop() const;
  void set_vdop(double value);

  // optional .apollo.canbus.GpsQuality quality = 37;
  bool has_quality() const;
  void clear_quality();
  static const int kQualityFieldNumber = 37;
  ::apollo::canbus::GpsQuality quality() const;
  void set_quality(::apollo::canbus::GpsQuality value);

  // optional int32 num_satellites = 38;
  bool has_num_satellites() const;
  void clear_num_satellites();
  static const int kNumSatellitesFieldNumber = 38;
  ::google::protobuf::int32 num_satellites() const;
  void set_num_satellites(::google::protobuf::int32 value);

  // optional double gps_speed = 39;
  bool has_gps_speed() const;
  void clear_gps_speed();
  static const int kGpsSpeedFieldNumber = 39;
  double gps_speed() const;
  void set_gps_speed(double value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.BasicInfo)
 private:
  void set_has_is_auto_mode();
  void clear_has_is_auto_mode();
  void set_has_power_state();
  void clear_has_power_state();
  void set_has_is_air_bag_deployed();
  void clear_has_is_air_bag_deployed();
  void set_has_odo_meter();
  void clear_has_odo_meter();
  void set_has_drive_range();
  void clear_has_drive_range();
  void set_has_is_system_error();
  void clear_has_is_system_error();
  void set_has_is_human_interrupt();
  void clear_has_is_human_interrupt();
  void set_has_acc_on_button();
  void clear_has_acc_on_button();
  void set_has_acc_off_button();
  void clear_has_acc_off_button();
  void set_has_acc_res_button();
  void clear_has_acc_res_button();
  void set_has_acc_cancel_button();
  void clear_has_acc_cancel_button();
  void set_has_acc_on_off_button();
  void clear_has_acc_on_off_button();
  void set_has_acc_res_cancel_button();
  void clear_has_acc_res_cancel_button();
  void set_has_acc_inc_spd_button();
  void clear_has_acc_inc_spd_button();
  void set_has_acc_dec_spd_button();
  void clear_has_acc_dec_spd_button();
  void set_has_acc_inc_gap_button();
  void clear_has_acc_inc_gap_button();
  void set_has_acc_dec_gap_button();
  void clear_has_acc_dec_gap_button();
  void set_has_lka_button();
  void clear_has_lka_button();
  void set_has_canbus_fault();
  void clear_has_canbus_fault();
  void set_has_latitude();
  void clear_has_latitude();
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_gps_valid();
  void clear_has_gps_valid();
  void set_has_year();
  void clear_has_year();
  void set_has_month();
  void clear_has_month();
  void set_has_day();
  void clear_has_day();
  void set_has_hours();
  void clear_has_hours();
  void set_has_minutes();
  void clear_has_minutes();
  void set_has_seconds();
  void clear_has_seconds();
  void set_has_compass_direction();
  void clear_has_compass_direction();
  void set_has_pdop();
  void clear_has_pdop();
  void set_has_is_gps_fault();
  void clear_has_is_gps_fault();
  void set_has_is_inferred();
  void clear_has_is_inferred();
  void set_has_altitude();
  void clear_has_altitude();
  void set_has_heading();
  void clear_has_heading();
  void set_has_hdop();
  void clear_has_hdop();
  void set_has_vdop();
  void clear_has_vdop();
  void set_has_quality();
  void clear_has_quality();
  void set_has_num_satellites();
  void clear_has_num_satellites();
  void set_has_gps_speed();
  void clear_has_gps_speed();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<2> _has_bits_;
  int power_state_;
  bool is_auto_mode_;
  bool is_air_bag_deployed_;
  bool is_system_error_;
  bool is_human_interrupt_;
  double odo_meter_;
  double drive_range_;
  bool acc_on_button_;
  bool acc_off_button_;
  bool acc_res_button_;
  bool acc_cancel_button_;
  bool acc_on_off_button_;
  bool acc_res_cancel_button_;
  bool acc_inc_spd_button_;
  bool acc_dec_spd_button_;
  bool acc_inc_gap_button_;
  bool acc_dec_gap_button_;
  bool lka_button_;
  bool canbus_fault_;
  ::google::protobuf::int32 year_;
  double latitude_;
  double longitude_;
  ::google::protobuf::int32 month_;
  ::google::protobuf::int32 day_;
  ::google::protobuf::int32 hours_;
  ::google::protobuf::int32 minutes_;
  ::google::protobuf::int32 seconds_;
  bool gps_valid_;
  bool is_gps_fault_;
  bool is_inferred_;
  double compass_direction_;
  double pdop_;
  double altitude_;
  double heading_;
  double hdop_;
  double vdop_;
  int quality_;
  ::google::protobuf::int32 num_satellites_;
  double gps_speed_;
  mutable int _cached_size_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class License : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.License) */ {
 public:
  License();
  virtual ~License();

  License(const License& from);

  inline License& operator=(const License& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const License& default_instance();

  static inline const License* internal_default_instance() {
    return reinterpret_cast<const License*>(
               &_License_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(License* other);

  // implements Message ----------------------------------------------

  inline License* New() const PROTOBUF_FINAL { return New(NULL); }

  License* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const License& from);
  void MergeFrom(const License& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(License* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string vin = 1;
  bool has_vin() const;
  void clear_vin();
  static const int kVinFieldNumber = 1;
  const ::std::string& vin() const;
  void set_vin(const ::std::string& value);
  #if LANG_CXX11
  void set_vin(::std::string&& value);
  #endif
  void set_vin(const char* value);
  void set_vin(const char* value, size_t size);
  ::std::string* mutable_vin();
  ::std::string* release_vin();
  void set_allocated_vin(::std::string* vin);

  // @@protoc_insertion_point(class_scope:apollo.canbus.License)
 private:
  void set_has_vin();
  void clear_has_vin();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr vin_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ChassisDetail

// optional .apollo.canbus.ChassisDetail.Type car_type = 1;
inline bool ChassisDetail::has_car_type() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ChassisDetail::set_has_car_type() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ChassisDetail::clear_has_car_type() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ChassisDetail::clear_car_type() {
  car_type_ = 0;
  clear_has_car_type();
}
inline ::apollo::canbus::ChassisDetail_Type ChassisDetail::car_type() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.car_type)
  return static_cast< ::apollo::canbus::ChassisDetail_Type >(car_type_);
}
inline void ChassisDetail::set_car_type(::apollo::canbus::ChassisDetail_Type value) {
  assert(::apollo::canbus::ChassisDetail_Type_IsValid(value));
  set_has_car_type();
  car_type_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.ChassisDetail.car_type)
}

// optional .apollo.canbus.BasicInfo basic = 2;
inline bool ChassisDetail::has_basic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChassisDetail::set_has_basic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChassisDetail::clear_has_basic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChassisDetail::clear_basic() {
  if (basic_ != NULL) basic_->::apollo::canbus::BasicInfo::Clear();
  clear_has_basic();
}
inline const ::apollo::canbus::BasicInfo& ChassisDetail::basic() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.basic)
  return basic_ != NULL ? *basic_
                         : *::apollo::canbus::BasicInfo::internal_default_instance();
}
inline ::apollo::canbus::BasicInfo* ChassisDetail::mutable_basic() {
  set_has_basic();
  if (basic_ == NULL) {
    basic_ = new ::apollo::canbus::BasicInfo;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.basic)
  return basic_;
}
inline ::apollo::canbus::BasicInfo* ChassisDetail::release_basic() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.basic)
  clear_has_basic();
  ::apollo::canbus::BasicInfo* temp = basic_;
  basic_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_basic(::apollo::canbus::BasicInfo* basic) {
  delete basic_;
  basic_ = basic;
  if (basic) {
    set_has_basic();
  } else {
    clear_has_basic();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.basic)
}

// optional .apollo.canbus.Safety safety = 3;
inline bool ChassisDetail::has_safety() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChassisDetail::set_has_safety() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChassisDetail::clear_has_safety() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChassisDetail::clear_safety() {
  if (safety_ != NULL) safety_->::apollo::canbus::Safety::Clear();
  clear_has_safety();
}
inline const ::apollo::canbus::Safety& ChassisDetail::safety() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.safety)
  return safety_ != NULL ? *safety_
                         : *::apollo::canbus::Safety::internal_default_instance();
}
inline ::apollo::canbus::Safety* ChassisDetail::mutable_safety() {
  set_has_safety();
  if (safety_ == NULL) {
    safety_ = new ::apollo::canbus::Safety;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.safety)
  return safety_;
}
inline ::apollo::canbus::Safety* ChassisDetail::release_safety() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.safety)
  clear_has_safety();
  ::apollo::canbus::Safety* temp = safety_;
  safety_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_safety(::apollo::canbus::Safety* safety) {
  delete safety_;
  safety_ = safety;
  if (safety) {
    set_has_safety();
  } else {
    clear_has_safety();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.safety)
}

// optional .apollo.canbus.Gear gear = 4;
inline bool ChassisDetail::has_gear() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChassisDetail::set_has_gear() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChassisDetail::clear_has_gear() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChassisDetail::clear_gear() {
  if (gear_ != NULL) gear_->::apollo::canbus::Gear::Clear();
  clear_has_gear();
}
inline const ::apollo::canbus::Gear& ChassisDetail::gear() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.gear)
  return gear_ != NULL ? *gear_
                         : *::apollo::canbus::Gear::internal_default_instance();
}
inline ::apollo::canbus::Gear* ChassisDetail::mutable_gear() {
  set_has_gear();
  if (gear_ == NULL) {
    gear_ = new ::apollo::canbus::Gear;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.gear)
  return gear_;
}
inline ::apollo::canbus::Gear* ChassisDetail::release_gear() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.gear)
  clear_has_gear();
  ::apollo::canbus::Gear* temp = gear_;
  gear_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_gear(::apollo::canbus::Gear* gear) {
  delete gear_;
  gear_ = gear;
  if (gear) {
    set_has_gear();
  } else {
    clear_has_gear();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.gear)
}

// optional .apollo.canbus.Ems ems = 5;
inline bool ChassisDetail::has_ems() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChassisDetail::set_has_ems() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChassisDetail::clear_has_ems() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChassisDetail::clear_ems() {
  if (ems_ != NULL) ems_->::apollo::canbus::Ems::Clear();
  clear_has_ems();
}
inline const ::apollo::canbus::Ems& ChassisDetail::ems() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.ems)
  return ems_ != NULL ? *ems_
                         : *::apollo::canbus::Ems::internal_default_instance();
}
inline ::apollo::canbus::Ems* ChassisDetail::mutable_ems() {
  set_has_ems();
  if (ems_ == NULL) {
    ems_ = new ::apollo::canbus::Ems;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.ems)
  return ems_;
}
inline ::apollo::canbus::Ems* ChassisDetail::release_ems() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.ems)
  clear_has_ems();
  ::apollo::canbus::Ems* temp = ems_;
  ems_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_ems(::apollo::canbus::Ems* ems) {
  delete ems_;
  ems_ = ems;
  if (ems) {
    set_has_ems();
  } else {
    clear_has_ems();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.ems)
}

// optional .apollo.canbus.Esp esp = 6;
inline bool ChassisDetail::has_esp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChassisDetail::set_has_esp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChassisDetail::clear_has_esp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChassisDetail::clear_esp() {
  if (esp_ != NULL) esp_->::apollo::canbus::Esp::Clear();
  clear_has_esp();
}
inline const ::apollo::canbus::Esp& ChassisDetail::esp() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.esp)
  return esp_ != NULL ? *esp_
                         : *::apollo::canbus::Esp::internal_default_instance();
}
inline ::apollo::canbus::Esp* ChassisDetail::mutable_esp() {
  set_has_esp();
  if (esp_ == NULL) {
    esp_ = new ::apollo::canbus::Esp;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.esp)
  return esp_;
}
inline ::apollo::canbus::Esp* ChassisDetail::release_esp() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.esp)
  clear_has_esp();
  ::apollo::canbus::Esp* temp = esp_;
  esp_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_esp(::apollo::canbus::Esp* esp) {
  delete esp_;
  esp_ = esp;
  if (esp) {
    set_has_esp();
  } else {
    clear_has_esp();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.esp)
}

// optional .apollo.canbus.Gas gas = 7;
inline bool ChassisDetail::has_gas() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChassisDetail::set_has_gas() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChassisDetail::clear_has_gas() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChassisDetail::clear_gas() {
  if (gas_ != NULL) gas_->::apollo::canbus::Gas::Clear();
  clear_has_gas();
}
inline const ::apollo::canbus::Gas& ChassisDetail::gas() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.gas)
  return gas_ != NULL ? *gas_
                         : *::apollo::canbus::Gas::internal_default_instance();
}
inline ::apollo::canbus::Gas* ChassisDetail::mutable_gas() {
  set_has_gas();
  if (gas_ == NULL) {
    gas_ = new ::apollo::canbus::Gas;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.gas)
  return gas_;
}
inline ::apollo::canbus::Gas* ChassisDetail::release_gas() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.gas)
  clear_has_gas();
  ::apollo::canbus::Gas* temp = gas_;
  gas_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_gas(::apollo::canbus::Gas* gas) {
  delete gas_;
  gas_ = gas;
  if (gas) {
    set_has_gas();
  } else {
    clear_has_gas();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.gas)
}

// optional .apollo.canbus.Epb epb = 8;
inline bool ChassisDetail::has_epb() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ChassisDetail::set_has_epb() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ChassisDetail::clear_has_epb() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ChassisDetail::clear_epb() {
  if (epb_ != NULL) epb_->::apollo::canbus::Epb::Clear();
  clear_has_epb();
}
inline const ::apollo::canbus::Epb& ChassisDetail::epb() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.epb)
  return epb_ != NULL ? *epb_
                         : *::apollo::canbus::Epb::internal_default_instance();
}
inline ::apollo::canbus::Epb* ChassisDetail::mutable_epb() {
  set_has_epb();
  if (epb_ == NULL) {
    epb_ = new ::apollo::canbus::Epb;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.epb)
  return epb_;
}
inline ::apollo::canbus::Epb* ChassisDetail::release_epb() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.epb)
  clear_has_epb();
  ::apollo::canbus::Epb* temp = epb_;
  epb_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_epb(::apollo::canbus::Epb* epb) {
  delete epb_;
  epb_ = epb;
  if (epb) {
    set_has_epb();
  } else {
    clear_has_epb();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.epb)
}

// optional .apollo.canbus.Brake brake = 9;
inline bool ChassisDetail::has_brake() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ChassisDetail::set_has_brake() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ChassisDetail::clear_has_brake() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ChassisDetail::clear_brake() {
  if (brake_ != NULL) brake_->::apollo::canbus::Brake::Clear();
  clear_has_brake();
}
inline const ::apollo::canbus::Brake& ChassisDetail::brake() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.brake)
  return brake_ != NULL ? *brake_
                         : *::apollo::canbus::Brake::internal_default_instance();
}
inline ::apollo::canbus::Brake* ChassisDetail::mutable_brake() {
  set_has_brake();
  if (brake_ == NULL) {
    brake_ = new ::apollo::canbus::Brake;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.brake)
  return brake_;
}
inline ::apollo::canbus::Brake* ChassisDetail::release_brake() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.brake)
  clear_has_brake();
  ::apollo::canbus::Brake* temp = brake_;
  brake_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_brake(::apollo::canbus::Brake* brake) {
  delete brake_;
  brake_ = brake;
  if (brake) {
    set_has_brake();
  } else {
    clear_has_brake();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.brake)
}

// optional .apollo.canbus.Deceleration deceleration = 10;
inline bool ChassisDetail::has_deceleration() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ChassisDetail::set_has_deceleration() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ChassisDetail::clear_has_deceleration() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ChassisDetail::clear_deceleration() {
  if (deceleration_ != NULL) deceleration_->::apollo::canbus::Deceleration::Clear();
  clear_has_deceleration();
}
inline const ::apollo::canbus::Deceleration& ChassisDetail::deceleration() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.deceleration)
  return deceleration_ != NULL ? *deceleration_
                         : *::apollo::canbus::Deceleration::internal_default_instance();
}
inline ::apollo::canbus::Deceleration* ChassisDetail::mutable_deceleration() {
  set_has_deceleration();
  if (deceleration_ == NULL) {
    deceleration_ = new ::apollo::canbus::Deceleration;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.deceleration)
  return deceleration_;
}
inline ::apollo::canbus::Deceleration* ChassisDetail::release_deceleration() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.deceleration)
  clear_has_deceleration();
  ::apollo::canbus::Deceleration* temp = deceleration_;
  deceleration_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_deceleration(::apollo::canbus::Deceleration* deceleration) {
  delete deceleration_;
  deceleration_ = deceleration;
  if (deceleration) {
    set_has_deceleration();
  } else {
    clear_has_deceleration();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.deceleration)
}

// optional .apollo.canbus.VehicleSpd vehicle_spd = 11;
inline bool ChassisDetail::has_vehicle_spd() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ChassisDetail::set_has_vehicle_spd() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ChassisDetail::clear_has_vehicle_spd() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ChassisDetail::clear_vehicle_spd() {
  if (vehicle_spd_ != NULL) vehicle_spd_->::apollo::canbus::VehicleSpd::Clear();
  clear_has_vehicle_spd();
}
inline const ::apollo::canbus::VehicleSpd& ChassisDetail::vehicle_spd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.vehicle_spd)
  return vehicle_spd_ != NULL ? *vehicle_spd_
                         : *::apollo::canbus::VehicleSpd::internal_default_instance();
}
inline ::apollo::canbus::VehicleSpd* ChassisDetail::mutable_vehicle_spd() {
  set_has_vehicle_spd();
  if (vehicle_spd_ == NULL) {
    vehicle_spd_ = new ::apollo::canbus::VehicleSpd;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.vehicle_spd)
  return vehicle_spd_;
}
inline ::apollo::canbus::VehicleSpd* ChassisDetail::release_vehicle_spd() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.vehicle_spd)
  clear_has_vehicle_spd();
  ::apollo::canbus::VehicleSpd* temp = vehicle_spd_;
  vehicle_spd_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_vehicle_spd(::apollo::canbus::VehicleSpd* vehicle_spd) {
  delete vehicle_spd_;
  vehicle_spd_ = vehicle_spd;
  if (vehicle_spd) {
    set_has_vehicle_spd();
  } else {
    clear_has_vehicle_spd();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.vehicle_spd)
}

// optional .apollo.canbus.Eps eps = 12;
inline bool ChassisDetail::has_eps() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ChassisDetail::set_has_eps() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ChassisDetail::clear_has_eps() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ChassisDetail::clear_eps() {
  if (eps_ != NULL) eps_->::apollo::canbus::Eps::Clear();
  clear_has_eps();
}
inline const ::apollo::canbus::Eps& ChassisDetail::eps() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.eps)
  return eps_ != NULL ? *eps_
                         : *::apollo::canbus::Eps::internal_default_instance();
}
inline ::apollo::canbus::Eps* ChassisDetail::mutable_eps() {
  set_has_eps();
  if (eps_ == NULL) {
    eps_ = new ::apollo::canbus::Eps;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.eps)
  return eps_;
}
inline ::apollo::canbus::Eps* ChassisDetail::release_eps() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.eps)
  clear_has_eps();
  ::apollo::canbus::Eps* temp = eps_;
  eps_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_eps(::apollo::canbus::Eps* eps) {
  delete eps_;
  eps_ = eps;
  if (eps) {
    set_has_eps();
  } else {
    clear_has_eps();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.eps)
}

// optional .apollo.canbus.Light light = 13;
inline bool ChassisDetail::has_light() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ChassisDetail::set_has_light() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ChassisDetail::clear_has_light() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ChassisDetail::clear_light() {
  if (light_ != NULL) light_->::apollo::canbus::Light::Clear();
  clear_has_light();
}
inline const ::apollo::canbus::Light& ChassisDetail::light() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.light)
  return light_ != NULL ? *light_
                         : *::apollo::canbus::Light::internal_default_instance();
}
inline ::apollo::canbus::Light* ChassisDetail::mutable_light() {
  set_has_light();
  if (light_ == NULL) {
    light_ = new ::apollo::canbus::Light;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.light)
  return light_;
}
inline ::apollo::canbus::Light* ChassisDetail::release_light() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.light)
  clear_has_light();
  ::apollo::canbus::Light* temp = light_;
  light_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_light(::apollo::canbus::Light* light) {
  delete light_;
  light_ = light;
  if (light) {
    set_has_light();
  } else {
    clear_has_light();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.light)
}

// optional .apollo.canbus.Battery battery = 14;
inline bool ChassisDetail::has_battery() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ChassisDetail::set_has_battery() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ChassisDetail::clear_has_battery() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ChassisDetail::clear_battery() {
  if (battery_ != NULL) battery_->::apollo::canbus::Battery::Clear();
  clear_has_battery();
}
inline const ::apollo::canbus::Battery& ChassisDetail::battery() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.battery)
  return battery_ != NULL ? *battery_
                         : *::apollo::canbus::Battery::internal_default_instance();
}
inline ::apollo::canbus::Battery* ChassisDetail::mutable_battery() {
  set_has_battery();
  if (battery_ == NULL) {
    battery_ = new ::apollo::canbus::Battery;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.battery)
  return battery_;
}
inline ::apollo::canbus::Battery* ChassisDetail::release_battery() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.battery)
  clear_has_battery();
  ::apollo::canbus::Battery* temp = battery_;
  battery_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_battery(::apollo::canbus::Battery* battery) {
  delete battery_;
  battery_ = battery;
  if (battery) {
    set_has_battery();
  } else {
    clear_has_battery();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.battery)
}

// optional .apollo.canbus.CheckResponseSignal check_response = 15;
inline bool ChassisDetail::has_check_response() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ChassisDetail::set_has_check_response() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ChassisDetail::clear_has_check_response() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ChassisDetail::clear_check_response() {
  if (check_response_ != NULL) check_response_->::apollo::canbus::CheckResponseSignal::Clear();
  clear_has_check_response();
}
inline const ::apollo::canbus::CheckResponseSignal& ChassisDetail::check_response() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.check_response)
  return check_response_ != NULL ? *check_response_
                         : *::apollo::canbus::CheckResponseSignal::internal_default_instance();
}
inline ::apollo::canbus::CheckResponseSignal* ChassisDetail::mutable_check_response() {
  set_has_check_response();
  if (check_response_ == NULL) {
    check_response_ = new ::apollo::canbus::CheckResponseSignal;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.check_response)
  return check_response_;
}
inline ::apollo::canbus::CheckResponseSignal* ChassisDetail::release_check_response() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.check_response)
  clear_has_check_response();
  ::apollo::canbus::CheckResponseSignal* temp = check_response_;
  check_response_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_check_response(::apollo::canbus::CheckResponseSignal* check_response) {
  delete check_response_;
  check_response_ = check_response;
  if (check_response) {
    set_has_check_response();
  } else {
    clear_has_check_response();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.check_response)
}

// optional .apollo.canbus.License license = 16;
inline bool ChassisDetail::has_license() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ChassisDetail::set_has_license() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ChassisDetail::clear_has_license() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ChassisDetail::clear_license() {
  if (license_ != NULL) license_->::apollo::canbus::License::Clear();
  clear_has_license();
}
inline const ::apollo::canbus::License& ChassisDetail::license() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.ChassisDetail.license)
  return license_ != NULL ? *license_
                         : *::apollo::canbus::License::internal_default_instance();
}
inline ::apollo::canbus::License* ChassisDetail::mutable_license() {
  set_has_license();
  if (license_ == NULL) {
    license_ = new ::apollo::canbus::License;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.ChassisDetail.license)
  return license_;
}
inline ::apollo::canbus::License* ChassisDetail::release_license() {
  // @@protoc_insertion_point(field_release:apollo.canbus.ChassisDetail.license)
  clear_has_license();
  ::apollo::canbus::License* temp = license_;
  license_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_license(::apollo::canbus::License* license) {
  delete license_;
  license_ = license;
  if (license) {
    set_has_license();
  } else {
    clear_has_license();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.ChassisDetail.license)
}

// -------------------------------------------------------------------

// CheckResponseSignal

// optional bool is_eps_online = 1 [default = false];
inline bool CheckResponseSignal::has_is_eps_online() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckResponseSignal::set_has_is_eps_online() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckResponseSignal::clear_has_is_eps_online() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckResponseSignal::clear_is_eps_online() {
  is_eps_online_ = false;
  clear_has_is_eps_online();
}
inline bool CheckResponseSignal::is_eps_online() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.CheckResponseSignal.is_eps_online)
  return is_eps_online_;
}
inline void CheckResponseSignal::set_is_eps_online(bool value) {
  set_has_is_eps_online();
  is_eps_online_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.CheckResponseSignal.is_eps_online)
}

// optional bool is_epb_online = 2 [default = false];
inline bool CheckResponseSignal::has_is_epb_online() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckResponseSignal::set_has_is_epb_online() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckResponseSignal::clear_has_is_epb_online() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckResponseSignal::clear_is_epb_online() {
  is_epb_online_ = false;
  clear_has_is_epb_online();
}
inline bool CheckResponseSignal::is_epb_online() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.CheckResponseSignal.is_epb_online)
  return is_epb_online_;
}
inline void CheckResponseSignal::set_is_epb_online(bool value) {
  set_has_is_epb_online();
  is_epb_online_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.CheckResponseSignal.is_epb_online)
}

// optional bool is_esp_online = 3 [default = false];
inline bool CheckResponseSignal::has_is_esp_online() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckResponseSignal::set_has_is_esp_online() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckResponseSignal::clear_has_is_esp_online() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckResponseSignal::clear_is_esp_online() {
  is_esp_online_ = false;
  clear_has_is_esp_online();
}
inline bool CheckResponseSignal::is_esp_online() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.CheckResponseSignal.is_esp_online)
  return is_esp_online_;
}
inline void CheckResponseSignal::set_is_esp_online(bool value) {
  set_has_is_esp_online();
  is_esp_online_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.CheckResponseSignal.is_esp_online)
}

// optional bool is_vtog_online = 4 [default = false];
inline bool CheckResponseSignal::has_is_vtog_online() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CheckResponseSignal::set_has_is_vtog_online() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CheckResponseSignal::clear_has_is_vtog_online() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CheckResponseSignal::clear_is_vtog_online() {
  is_vtog_online_ = false;
  clear_has_is_vtog_online();
}
inline bool CheckResponseSignal::is_vtog_online() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.CheckResponseSignal.is_vtog_online)
  return is_vtog_online_;
}
inline void CheckResponseSignal::set_is_vtog_online(bool value) {
  set_has_is_vtog_online();
  is_vtog_online_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.CheckResponseSignal.is_vtog_online)
}

// optional bool is_scu_online = 5 [default = false];
inline bool CheckResponseSignal::has_is_scu_online() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CheckResponseSignal::set_has_is_scu_online() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CheckResponseSignal::clear_has_is_scu_online() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CheckResponseSignal::clear_is_scu_online() {
  is_scu_online_ = false;
  clear_has_is_scu_online();
}
inline bool CheckResponseSignal::is_scu_online() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.CheckResponseSignal.is_scu_online)
  return is_scu_online_;
}
inline void CheckResponseSignal::set_is_scu_online(bool value) {
  set_has_is_scu_online();
  is_scu_online_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.CheckResponseSignal.is_scu_online)
}

// optional bool is_switch_online = 6 [default = false];
inline bool CheckResponseSignal::has_is_switch_online() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CheckResponseSignal::set_has_is_switch_online() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CheckResponseSignal::clear_has_is_switch_online() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CheckResponseSignal::clear_is_switch_online() {
  is_switch_online_ = false;
  clear_has_is_switch_online();
}
inline bool CheckResponseSignal::is_switch_online() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.CheckResponseSignal.is_switch_online)
  return is_switch_online_;
}
inline void CheckResponseSignal::set_is_switch_online(bool value) {
  set_has_is_switch_online();
  is_switch_online_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.CheckResponseSignal.is_switch_online)
}

// optional bool is_vcu_online = 7 [default = false];
inline bool CheckResponseSignal::has_is_vcu_online() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CheckResponseSignal::set_has_is_vcu_online() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CheckResponseSignal::clear_has_is_vcu_online() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CheckResponseSignal::clear_is_vcu_online() {
  is_vcu_online_ = false;
  clear_has_is_vcu_online();
}
inline bool CheckResponseSignal::is_vcu_online() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.CheckResponseSignal.is_vcu_online)
  return is_vcu_online_;
}
inline void CheckResponseSignal::set_is_vcu_online(bool value) {
  set_has_is_vcu_online();
  is_vcu_online_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.CheckResponseSignal.is_vcu_online)
}

// -------------------------------------------------------------------

// Battery

// optional double battery_percent = 1;
inline bool Battery::has_battery_percent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Battery::set_has_battery_percent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Battery::clear_has_battery_percent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Battery::clear_battery_percent() {
  battery_percent_ = 0;
  clear_has_battery_percent();
}
inline double Battery::battery_percent() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Battery.battery_percent)
  return battery_percent_;
}
inline void Battery::set_battery_percent(double value) {
  set_has_battery_percent();
  battery_percent_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Battery.battery_percent)
}

// optional double fuel_level = 2;
inline bool Battery::has_fuel_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Battery::set_has_fuel_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Battery::clear_has_fuel_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Battery::clear_fuel_level() {
  fuel_level_ = 0;
  clear_has_fuel_level();
}
inline double Battery::fuel_level() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Battery.fuel_level)
  return fuel_level_;
}
inline void Battery::set_fuel_level(double value) {
  set_has_fuel_level();
  fuel_level_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Battery.fuel_level)
}

// -------------------------------------------------------------------

// Light

// optional .apollo.canbus.Light.TurnLightType turn_light_type = 1;
inline bool Light::has_turn_light_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Light::set_has_turn_light_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Light::clear_has_turn_light_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Light::clear_turn_light_type() {
  turn_light_type_ = 0;
  clear_has_turn_light_type();
}
inline ::apollo::canbus::Light_TurnLightType Light::turn_light_type() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.turn_light_type)
  return static_cast< ::apollo::canbus::Light_TurnLightType >(turn_light_type_);
}
inline void Light::set_turn_light_type(::apollo::canbus::Light_TurnLightType value) {
  assert(::apollo::canbus::Light_TurnLightType_IsValid(value));
  set_has_turn_light_type();
  turn_light_type_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.turn_light_type)
}

// optional .apollo.canbus.Light.LampType lamp_type = 2;
inline bool Light::has_lamp_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Light::set_has_lamp_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Light::clear_has_lamp_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Light::clear_lamp_type() {
  lamp_type_ = 0;
  clear_has_lamp_type();
}
inline ::apollo::canbus::Light_LampType Light::lamp_type() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.lamp_type)
  return static_cast< ::apollo::canbus::Light_LampType >(lamp_type_);
}
inline void Light::set_lamp_type(::apollo::canbus::Light_LampType value) {
  assert(::apollo::canbus::Light_LampType_IsValid(value));
  set_has_lamp_type();
  lamp_type_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.lamp_type)
}

// optional bool is_brake_lamp_on = 3;
inline bool Light::has_is_brake_lamp_on() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Light::set_has_is_brake_lamp_on() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Light::clear_has_is_brake_lamp_on() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Light::clear_is_brake_lamp_on() {
  is_brake_lamp_on_ = false;
  clear_has_is_brake_lamp_on();
}
inline bool Light::is_brake_lamp_on() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.is_brake_lamp_on)
  return is_brake_lamp_on_;
}
inline void Light::set_is_brake_lamp_on(bool value) {
  set_has_is_brake_lamp_on();
  is_brake_lamp_on_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.is_brake_lamp_on)
}

// optional bool is_auto_light = 4;
inline bool Light::has_is_auto_light() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Light::set_has_is_auto_light() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Light::clear_has_is_auto_light() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Light::clear_is_auto_light() {
  is_auto_light_ = false;
  clear_has_is_auto_light();
}
inline bool Light::is_auto_light() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.is_auto_light)
  return is_auto_light_;
}
inline void Light::set_is_auto_light(bool value) {
  set_has_is_auto_light();
  is_auto_light_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.is_auto_light)
}

// optional int32 wiper_gear = 5;
inline bool Light::has_wiper_gear() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Light::set_has_wiper_gear() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Light::clear_has_wiper_gear() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Light::clear_wiper_gear() {
  wiper_gear_ = 0;
  clear_has_wiper_gear();
}
inline ::google::protobuf::int32 Light::wiper_gear() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.wiper_gear)
  return wiper_gear_;
}
inline void Light::set_wiper_gear(::google::protobuf::int32 value) {
  set_has_wiper_gear();
  wiper_gear_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.wiper_gear)
}

// optional int32 lotion_gear = 6;
inline bool Light::has_lotion_gear() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Light::set_has_lotion_gear() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Light::clear_has_lotion_gear() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Light::clear_lotion_gear() {
  lotion_gear_ = 0;
  clear_has_lotion_gear();
}
inline ::google::protobuf::int32 Light::lotion_gear() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.lotion_gear)
  return lotion_gear_;
}
inline void Light::set_lotion_gear(::google::protobuf::int32 value) {
  set_has_lotion_gear();
  lotion_gear_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.lotion_gear)
}

// optional bool is_horn_on = 7;
inline bool Light::has_is_horn_on() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Light::set_has_is_horn_on() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Light::clear_has_is_horn_on() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Light::clear_is_horn_on() {
  is_horn_on_ = false;
  clear_has_is_horn_on();
}
inline bool Light::is_horn_on() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.is_horn_on)
  return is_horn_on_;
}
inline void Light::set_is_horn_on(bool value) {
  set_has_is_horn_on();
  is_horn_on_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.is_horn_on)
}

// optional .apollo.canbus.Light.LincolnLampType lincoln_lamp_type = 8;
inline bool Light::has_lincoln_lamp_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Light::set_has_lincoln_lamp_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Light::clear_has_lincoln_lamp_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Light::clear_lincoln_lamp_type() {
  lincoln_lamp_type_ = 0;
  clear_has_lincoln_lamp_type();
}
inline ::apollo::canbus::Light_LincolnLampType Light::lincoln_lamp_type() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.lincoln_lamp_type)
  return static_cast< ::apollo::canbus::Light_LincolnLampType >(lincoln_lamp_type_);
}
inline void Light::set_lincoln_lamp_type(::apollo::canbus::Light_LincolnLampType value) {
  assert(::apollo::canbus::Light_LincolnLampType_IsValid(value));
  set_has_lincoln_lamp_type();
  lincoln_lamp_type_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.lincoln_lamp_type)
}

// optional .apollo.canbus.Light.LincolnWiperType lincoln_wiper = 9;
inline bool Light::has_lincoln_wiper() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Light::set_has_lincoln_wiper() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Light::clear_has_lincoln_wiper() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Light::clear_lincoln_wiper() {
  lincoln_wiper_ = 0;
  clear_has_lincoln_wiper();
}
inline ::apollo::canbus::Light_LincolnWiperType Light::lincoln_wiper() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.lincoln_wiper)
  return static_cast< ::apollo::canbus::Light_LincolnWiperType >(lincoln_wiper_);
}
inline void Light::set_lincoln_wiper(::apollo::canbus::Light_LincolnWiperType value) {
  assert(::apollo::canbus::Light_LincolnWiperType_IsValid(value));
  set_has_lincoln_wiper();
  lincoln_wiper_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.lincoln_wiper)
}

// optional .apollo.canbus.Light.LincolnAmbientType lincoln_ambient = 10;
inline bool Light::has_lincoln_ambient() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Light::set_has_lincoln_ambient() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Light::clear_has_lincoln_ambient() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Light::clear_lincoln_ambient() {
  lincoln_ambient_ = 0;
  clear_has_lincoln_ambient();
}
inline ::apollo::canbus::Light_LincolnAmbientType Light::lincoln_ambient() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Light.lincoln_ambient)
  return static_cast< ::apollo::canbus::Light_LincolnAmbientType >(lincoln_ambient_);
}
inline void Light::set_lincoln_ambient(::apollo::canbus::Light_LincolnAmbientType value) {
  assert(::apollo::canbus::Light_LincolnAmbientType_IsValid(value));
  set_has_lincoln_ambient();
  lincoln_ambient_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Light.lincoln_ambient)
}

// -------------------------------------------------------------------

// Eps

// optional bool is_eps_fail = 1;
inline bool Eps::has_is_eps_fail() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Eps::set_has_is_eps_fail() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Eps::clear_has_is_eps_fail() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Eps::clear_is_eps_fail() {
  is_eps_fail_ = false;
  clear_has_is_eps_fail();
}
inline bool Eps::is_eps_fail() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.is_eps_fail)
  return is_eps_fail_;
}
inline void Eps::set_is_eps_fail(bool value) {
  set_has_is_eps_fail();
  is_eps_fail_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.is_eps_fail)
}

// optional .apollo.canbus.Eps.Type eps_control_state = 2;
inline bool Eps::has_eps_control_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Eps::set_has_eps_control_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Eps::clear_has_eps_control_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Eps::clear_eps_control_state() {
  eps_control_state_ = 0;
  clear_has_eps_control_state();
}
inline ::apollo::canbus::Eps_Type Eps::eps_control_state() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.eps_control_state)
  return static_cast< ::apollo::canbus::Eps_Type >(eps_control_state_);
}
inline void Eps::set_eps_control_state(::apollo::canbus::Eps_Type value) {
  assert(::apollo::canbus::Eps_Type_IsValid(value));
  set_has_eps_control_state();
  eps_control_state_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.eps_control_state)
}

// optional double eps_driver_hand_torq = 3;
inline bool Eps::has_eps_driver_hand_torq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Eps::set_has_eps_driver_hand_torq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Eps::clear_has_eps_driver_hand_torq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Eps::clear_eps_driver_hand_torq() {
  eps_driver_hand_torq_ = 0;
  clear_has_eps_driver_hand_torq();
}
inline double Eps::eps_driver_hand_torq() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.eps_driver_hand_torq)
  return eps_driver_hand_torq_;
}
inline void Eps::set_eps_driver_hand_torq(double value) {
  set_has_eps_driver_hand_torq();
  eps_driver_hand_torq_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.eps_driver_hand_torq)
}

// optional bool is_steering_angle_valid = 4;
inline bool Eps::has_is_steering_angle_valid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Eps::set_has_is_steering_angle_valid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Eps::clear_has_is_steering_angle_valid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Eps::clear_is_steering_angle_valid() {
  is_steering_angle_valid_ = false;
  clear_has_is_steering_angle_valid();
}
inline bool Eps::is_steering_angle_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.is_steering_angle_valid)
  return is_steering_angle_valid_;
}
inline void Eps::set_is_steering_angle_valid(bool value) {
  set_has_is_steering_angle_valid();
  is_steering_angle_valid_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.is_steering_angle_valid)
}

// optional double steering_angle = 5;
inline bool Eps::has_steering_angle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Eps::set_has_steering_angle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Eps::clear_has_steering_angle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Eps::clear_steering_angle() {
  steering_angle_ = 0;
  clear_has_steering_angle();
}
inline double Eps::steering_angle() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.steering_angle)
  return steering_angle_;
}
inline void Eps::set_steering_angle(double value) {
  set_has_steering_angle();
  steering_angle_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.steering_angle)
}

// optional double steering_angle_spd = 6;
inline bool Eps::has_steering_angle_spd() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Eps::set_has_steering_angle_spd() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Eps::clear_has_steering_angle_spd() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Eps::clear_steering_angle_spd() {
  steering_angle_spd_ = 0;
  clear_has_steering_angle_spd();
}
inline double Eps::steering_angle_spd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.steering_angle_spd)
  return steering_angle_spd_;
}
inline void Eps::set_steering_angle_spd(double value) {
  set_has_steering_angle_spd();
  steering_angle_spd_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.steering_angle_spd)
}

// optional bool is_trimming_status = 7;
inline bool Eps::has_is_trimming_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Eps::set_has_is_trimming_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Eps::clear_has_is_trimming_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Eps::clear_is_trimming_status() {
  is_trimming_status_ = false;
  clear_has_is_trimming_status();
}
inline bool Eps::is_trimming_status() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.is_trimming_status)
  return is_trimming_status_;
}
inline void Eps::set_is_trimming_status(bool value) {
  set_has_is_trimming_status();
  is_trimming_status_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.is_trimming_status)
}

// optional bool is_calibration_status = 8;
inline bool Eps::has_is_calibration_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Eps::set_has_is_calibration_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Eps::clear_has_is_calibration_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Eps::clear_is_calibration_status() {
  is_calibration_status_ = false;
  clear_has_is_calibration_status();
}
inline bool Eps::is_calibration_status() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.is_calibration_status)
  return is_calibration_status_;
}
inline void Eps::set_is_calibration_status(bool value) {
  set_has_is_calibration_status();
  is_calibration_status_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.is_calibration_status)
}

// optional bool is_failure_status = 9;
inline bool Eps::has_is_failure_status() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Eps::set_has_is_failure_status() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Eps::clear_has_is_failure_status() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Eps::clear_is_failure_status() {
  is_failure_status_ = false;
  clear_has_is_failure_status();
}
inline bool Eps::is_failure_status() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.is_failure_status)
  return is_failure_status_;
}
inline void Eps::set_is_failure_status(bool value) {
  set_has_is_failure_status();
  is_failure_status_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.is_failure_status)
}

// optional int32 allow_enter_autonomous_mode = 10;
inline bool Eps::has_allow_enter_autonomous_mode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Eps::set_has_allow_enter_autonomous_mode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Eps::clear_has_allow_enter_autonomous_mode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Eps::clear_allow_enter_autonomous_mode() {
  allow_enter_autonomous_mode_ = 0;
  clear_has_allow_enter_autonomous_mode();
}
inline ::google::protobuf::int32 Eps::allow_enter_autonomous_mode() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.allow_enter_autonomous_mode)
  return allow_enter_autonomous_mode_;
}
inline void Eps::set_allow_enter_autonomous_mode(::google::protobuf::int32 value) {
  set_has_allow_enter_autonomous_mode();
  allow_enter_autonomous_mode_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.allow_enter_autonomous_mode)
}

// optional int32 current_driving_mode = 11;
inline bool Eps::has_current_driving_mode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Eps::set_has_current_driving_mode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Eps::clear_has_current_driving_mode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Eps::clear_current_driving_mode() {
  current_driving_mode_ = 0;
  clear_has_current_driving_mode();
}
inline ::google::protobuf::int32 Eps::current_driving_mode() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.current_driving_mode)
  return current_driving_mode_;
}
inline void Eps::set_current_driving_mode(::google::protobuf::int32 value) {
  set_has_current_driving_mode();
  current_driving_mode_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.current_driving_mode)
}

// optional double steering_angle_cmd = 12;
inline bool Eps::has_steering_angle_cmd() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Eps::set_has_steering_angle_cmd() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Eps::clear_has_steering_angle_cmd() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Eps::clear_steering_angle_cmd() {
  steering_angle_cmd_ = 0;
  clear_has_steering_angle_cmd();
}
inline double Eps::steering_angle_cmd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.steering_angle_cmd)
  return steering_angle_cmd_;
}
inline void Eps::set_steering_angle_cmd(double value) {
  set_has_steering_angle_cmd();
  steering_angle_cmd_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.steering_angle_cmd)
}

// optional double vehicle_speed = 13;
inline bool Eps::has_vehicle_speed() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Eps::set_has_vehicle_speed() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Eps::clear_has_vehicle_speed() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Eps::clear_vehicle_speed() {
  vehicle_speed_ = 0;
  clear_has_vehicle_speed();
}
inline double Eps::vehicle_speed() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.vehicle_speed)
  return vehicle_speed_;
}
inline void Eps::set_vehicle_speed(double value) {
  set_has_vehicle_speed();
  vehicle_speed_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.vehicle_speed)
}

// optional double epas_torque = 14;
inline bool Eps::has_epas_torque() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Eps::set_has_epas_torque() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Eps::clear_has_epas_torque() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Eps::clear_epas_torque() {
  epas_torque_ = 0;
  clear_has_epas_torque();
}
inline double Eps::epas_torque() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.epas_torque)
  return epas_torque_;
}
inline void Eps::set_epas_torque(double value) {
  set_has_epas_torque();
  epas_torque_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.epas_torque)
}

// optional bool steering_enabled = 15;
inline bool Eps::has_steering_enabled() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Eps::set_has_steering_enabled() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Eps::clear_has_steering_enabled() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Eps::clear_steering_enabled() {
  steering_enabled_ = false;
  clear_has_steering_enabled();
}
inline bool Eps::steering_enabled() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.steering_enabled)
  return steering_enabled_;
}
inline void Eps::set_steering_enabled(bool value) {
  set_has_steering_enabled();
  steering_enabled_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.steering_enabled)
}

// optional bool driver_override = 16;
inline bool Eps::has_driver_override() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Eps::set_has_driver_override() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Eps::clear_has_driver_override() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Eps::clear_driver_override() {
  driver_override_ = false;
  clear_has_driver_override();
}
inline bool Eps::driver_override() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.driver_override)
  return driver_override_;
}
inline void Eps::set_driver_override(bool value) {
  set_has_driver_override();
  driver_override_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.driver_override)
}

// optional bool driver_activity = 17;
inline bool Eps::has_driver_activity() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Eps::set_has_driver_activity() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Eps::clear_has_driver_activity() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Eps::clear_driver_activity() {
  driver_activity_ = false;
  clear_has_driver_activity();
}
inline bool Eps::driver_activity() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.driver_activity)
  return driver_activity_;
}
inline void Eps::set_driver_activity(bool value) {
  set_has_driver_activity();
  driver_activity_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.driver_activity)
}

// optional bool watchdog_fault = 18;
inline bool Eps::has_watchdog_fault() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Eps::set_has_watchdog_fault() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Eps::clear_has_watchdog_fault() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Eps::clear_watchdog_fault() {
  watchdog_fault_ = false;
  clear_has_watchdog_fault();
}
inline bool Eps::watchdog_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.watchdog_fault)
  return watchdog_fault_;
}
inline void Eps::set_watchdog_fault(bool value) {
  set_has_watchdog_fault();
  watchdog_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.watchdog_fault)
}

// optional bool channel_1_fault = 19;
inline bool Eps::has_channel_1_fault() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Eps::set_has_channel_1_fault() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Eps::clear_has_channel_1_fault() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Eps::clear_channel_1_fault() {
  channel_1_fault_ = false;
  clear_has_channel_1_fault();
}
inline bool Eps::channel_1_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.channel_1_fault)
  return channel_1_fault_;
}
inline void Eps::set_channel_1_fault(bool value) {
  set_has_channel_1_fault();
  channel_1_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.channel_1_fault)
}

// optional bool channel_2_fault = 20;
inline bool Eps::has_channel_2_fault() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Eps::set_has_channel_2_fault() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Eps::clear_has_channel_2_fault() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Eps::clear_channel_2_fault() {
  channel_2_fault_ = false;
  clear_has_channel_2_fault();
}
inline bool Eps::channel_2_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.channel_2_fault)
  return channel_2_fault_;
}
inline void Eps::set_channel_2_fault(bool value) {
  set_has_channel_2_fault();
  channel_2_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.channel_2_fault)
}

// optional bool calibration_fault = 21;
inline bool Eps::has_calibration_fault() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Eps::set_has_calibration_fault() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Eps::clear_has_calibration_fault() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Eps::clear_calibration_fault() {
  calibration_fault_ = false;
  clear_has_calibration_fault();
}
inline bool Eps::calibration_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.calibration_fault)
  return calibration_fault_;
}
inline void Eps::set_calibration_fault(bool value) {
  set_has_calibration_fault();
  calibration_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.calibration_fault)
}

// optional bool connector_fault = 22;
inline bool Eps::has_connector_fault() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Eps::set_has_connector_fault() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Eps::clear_has_connector_fault() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Eps::clear_connector_fault() {
  connector_fault_ = false;
  clear_has_connector_fault();
}
inline bool Eps::connector_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.connector_fault)
  return connector_fault_;
}
inline void Eps::set_connector_fault(bool value) {
  set_has_connector_fault();
  connector_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.connector_fault)
}

// optional double timestamp_65 = 23;
inline bool Eps::has_timestamp_65() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Eps::set_has_timestamp_65() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Eps::clear_has_timestamp_65() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Eps::clear_timestamp_65() {
  timestamp_65_ = 0;
  clear_has_timestamp_65();
}
inline double Eps::timestamp_65() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.timestamp_65)
  return timestamp_65_;
}
inline void Eps::set_timestamp_65(double value) {
  set_has_timestamp_65();
  timestamp_65_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.timestamp_65)
}

// optional int32 major_version = 24;
inline bool Eps::has_major_version() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Eps::set_has_major_version() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Eps::clear_has_major_version() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Eps::clear_major_version() {
  major_version_ = 0;
  clear_has_major_version();
}
inline ::google::protobuf::int32 Eps::major_version() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.major_version)
  return major_version_;
}
inline void Eps::set_major_version(::google::protobuf::int32 value) {
  set_has_major_version();
  major_version_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.major_version)
}

// optional int32 minor_version = 25;
inline bool Eps::has_minor_version() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Eps::set_has_minor_version() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Eps::clear_has_minor_version() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Eps::clear_minor_version() {
  minor_version_ = 0;
  clear_has_minor_version();
}
inline ::google::protobuf::int32 Eps::minor_version() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.minor_version)
  return minor_version_;
}
inline void Eps::set_minor_version(::google::protobuf::int32 value) {
  set_has_minor_version();
  minor_version_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.minor_version)
}

// optional int32 build_number = 26;
inline bool Eps::has_build_number() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Eps::set_has_build_number() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Eps::clear_has_build_number() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Eps::clear_build_number() {
  build_number_ = 0;
  clear_has_build_number();
}
inline ::google::protobuf::int32 Eps::build_number() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Eps.build_number)
  return build_number_;
}
inline void Eps::set_build_number(::google::protobuf::int32 value) {
  set_has_build_number();
  build_number_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Eps.build_number)
}

// -------------------------------------------------------------------

// VehicleSpd

// optional bool is_vehicle_standstill = 1;
inline bool VehicleSpd::has_is_vehicle_standstill() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleSpd::set_has_is_vehicle_standstill() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleSpd::clear_has_is_vehicle_standstill() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleSpd::clear_is_vehicle_standstill() {
  is_vehicle_standstill_ = false;
  clear_has_is_vehicle_standstill();
}
inline bool VehicleSpd::is_vehicle_standstill() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.is_vehicle_standstill)
  return is_vehicle_standstill_;
}
inline void VehicleSpd::set_is_vehicle_standstill(bool value) {
  set_has_is_vehicle_standstill();
  is_vehicle_standstill_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.is_vehicle_standstill)
}

// optional bool is_vehicle_spd_valid = 2;
inline bool VehicleSpd::has_is_vehicle_spd_valid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleSpd::set_has_is_vehicle_spd_valid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleSpd::clear_has_is_vehicle_spd_valid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleSpd::clear_is_vehicle_spd_valid() {
  is_vehicle_spd_valid_ = false;
  clear_has_is_vehicle_spd_valid();
}
inline bool VehicleSpd::is_vehicle_spd_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.is_vehicle_spd_valid)
  return is_vehicle_spd_valid_;
}
inline void VehicleSpd::set_is_vehicle_spd_valid(bool value) {
  set_has_is_vehicle_spd_valid();
  is_vehicle_spd_valid_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.is_vehicle_spd_valid)
}

// optional double vehicle_spd = 3 [default = 0];
inline bool VehicleSpd::has_vehicle_spd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleSpd::set_has_vehicle_spd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleSpd::clear_has_vehicle_spd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleSpd::clear_vehicle_spd() {
  vehicle_spd_ = 0;
  clear_has_vehicle_spd();
}
inline double VehicleSpd::vehicle_spd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.vehicle_spd)
  return vehicle_spd_;
}
inline void VehicleSpd::set_vehicle_spd(double value) {
  set_has_vehicle_spd();
  vehicle_spd_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.vehicle_spd)
}

// optional bool is_wheel_spd_rr_valid = 4;
inline bool VehicleSpd::has_is_wheel_spd_rr_valid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehicleSpd::set_has_is_wheel_spd_rr_valid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehicleSpd::clear_has_is_wheel_spd_rr_valid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehicleSpd::clear_is_wheel_spd_rr_valid() {
  is_wheel_spd_rr_valid_ = false;
  clear_has_is_wheel_spd_rr_valid();
}
inline bool VehicleSpd::is_wheel_spd_rr_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.is_wheel_spd_rr_valid)
  return is_wheel_spd_rr_valid_;
}
inline void VehicleSpd::set_is_wheel_spd_rr_valid(bool value) {
  set_has_is_wheel_spd_rr_valid();
  is_wheel_spd_rr_valid_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.is_wheel_spd_rr_valid)
}

// optional .apollo.canbus.VehicleSpd.Type wheel_direction_rr = 5;
inline bool VehicleSpd::has_wheel_direction_rr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VehicleSpd::set_has_wheel_direction_rr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VehicleSpd::clear_has_wheel_direction_rr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VehicleSpd::clear_wheel_direction_rr() {
  wheel_direction_rr_ = 0;
  clear_has_wheel_direction_rr();
}
inline ::apollo::canbus::VehicleSpd_Type VehicleSpd::wheel_direction_rr() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.wheel_direction_rr)
  return static_cast< ::apollo::canbus::VehicleSpd_Type >(wheel_direction_rr_);
}
inline void VehicleSpd::set_wheel_direction_rr(::apollo::canbus::VehicleSpd_Type value) {
  assert(::apollo::canbus::VehicleSpd_Type_IsValid(value));
  set_has_wheel_direction_rr();
  wheel_direction_rr_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.wheel_direction_rr)
}

// optional double wheel_spd_rr = 6;
inline bool VehicleSpd::has_wheel_spd_rr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VehicleSpd::set_has_wheel_spd_rr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VehicleSpd::clear_has_wheel_spd_rr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VehicleSpd::clear_wheel_spd_rr() {
  wheel_spd_rr_ = 0;
  clear_has_wheel_spd_rr();
}
inline double VehicleSpd::wheel_spd_rr() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.wheel_spd_rr)
  return wheel_spd_rr_;
}
inline void VehicleSpd::set_wheel_spd_rr(double value) {
  set_has_wheel_spd_rr();
  wheel_spd_rr_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.wheel_spd_rr)
}

// optional bool is_wheel_spd_rl_valid = 7;
inline bool VehicleSpd::has_is_wheel_spd_rl_valid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehicleSpd::set_has_is_wheel_spd_rl_valid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehicleSpd::clear_has_is_wheel_spd_rl_valid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehicleSpd::clear_is_wheel_spd_rl_valid() {
  is_wheel_spd_rl_valid_ = false;
  clear_has_is_wheel_spd_rl_valid();
}
inline bool VehicleSpd::is_wheel_spd_rl_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.is_wheel_spd_rl_valid)
  return is_wheel_spd_rl_valid_;
}
inline void VehicleSpd::set_is_wheel_spd_rl_valid(bool value) {
  set_has_is_wheel_spd_rl_valid();
  is_wheel_spd_rl_valid_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.is_wheel_spd_rl_valid)
}

// optional .apollo.canbus.VehicleSpd.Type wheel_direction_rl = 8;
inline bool VehicleSpd::has_wheel_direction_rl() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VehicleSpd::set_has_wheel_direction_rl() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VehicleSpd::clear_has_wheel_direction_rl() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VehicleSpd::clear_wheel_direction_rl() {
  wheel_direction_rl_ = 0;
  clear_has_wheel_direction_rl();
}
inline ::apollo::canbus::VehicleSpd_Type VehicleSpd::wheel_direction_rl() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.wheel_direction_rl)
  return static_cast< ::apollo::canbus::VehicleSpd_Type >(wheel_direction_rl_);
}
inline void VehicleSpd::set_wheel_direction_rl(::apollo::canbus::VehicleSpd_Type value) {
  assert(::apollo::canbus::VehicleSpd_Type_IsValid(value));
  set_has_wheel_direction_rl();
  wheel_direction_rl_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.wheel_direction_rl)
}

// optional double wheel_spd_rl = 9;
inline bool VehicleSpd::has_wheel_spd_rl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VehicleSpd::set_has_wheel_spd_rl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VehicleSpd::clear_has_wheel_spd_rl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VehicleSpd::clear_wheel_spd_rl() {
  wheel_spd_rl_ = 0;
  clear_has_wheel_spd_rl();
}
inline double VehicleSpd::wheel_spd_rl() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.wheel_spd_rl)
  return wheel_spd_rl_;
}
inline void VehicleSpd::set_wheel_spd_rl(double value) {
  set_has_wheel_spd_rl();
  wheel_spd_rl_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.wheel_spd_rl)
}

// optional bool is_wheel_spd_fr_valid = 10;
inline bool VehicleSpd::has_is_wheel_spd_fr_valid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void VehicleSpd::set_has_is_wheel_spd_fr_valid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void VehicleSpd::clear_has_is_wheel_spd_fr_valid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void VehicleSpd::clear_is_wheel_spd_fr_valid() {
  is_wheel_spd_fr_valid_ = false;
  clear_has_is_wheel_spd_fr_valid();
}
inline bool VehicleSpd::is_wheel_spd_fr_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.is_wheel_spd_fr_valid)
  return is_wheel_spd_fr_valid_;
}
inline void VehicleSpd::set_is_wheel_spd_fr_valid(bool value) {
  set_has_is_wheel_spd_fr_valid();
  is_wheel_spd_fr_valid_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.is_wheel_spd_fr_valid)
}

// optional .apollo.canbus.VehicleSpd.Type wheel_direction_fr = 11;
inline bool VehicleSpd::has_wheel_direction_fr() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VehicleSpd::set_has_wheel_direction_fr() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VehicleSpd::clear_has_wheel_direction_fr() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VehicleSpd::clear_wheel_direction_fr() {
  wheel_direction_fr_ = 0;
  clear_has_wheel_direction_fr();
}
inline ::apollo::canbus::VehicleSpd_Type VehicleSpd::wheel_direction_fr() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.wheel_direction_fr)
  return static_cast< ::apollo::canbus::VehicleSpd_Type >(wheel_direction_fr_);
}
inline void VehicleSpd::set_wheel_direction_fr(::apollo::canbus::VehicleSpd_Type value) {
  assert(::apollo::canbus::VehicleSpd_Type_IsValid(value));
  set_has_wheel_direction_fr();
  wheel_direction_fr_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.wheel_direction_fr)
}

// optional double wheel_spd_fr = 12;
inline bool VehicleSpd::has_wheel_spd_fr() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VehicleSpd::set_has_wheel_spd_fr() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VehicleSpd::clear_has_wheel_spd_fr() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VehicleSpd::clear_wheel_spd_fr() {
  wheel_spd_fr_ = 0;
  clear_has_wheel_spd_fr();
}
inline double VehicleSpd::wheel_spd_fr() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.wheel_spd_fr)
  return wheel_spd_fr_;
}
inline void VehicleSpd::set_wheel_spd_fr(double value) {
  set_has_wheel_spd_fr();
  wheel_spd_fr_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.wheel_spd_fr)
}

// optional bool is_wheel_spd_fl_valid = 13;
inline bool VehicleSpd::has_is_wheel_spd_fl_valid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void VehicleSpd::set_has_is_wheel_spd_fl_valid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void VehicleSpd::clear_has_is_wheel_spd_fl_valid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void VehicleSpd::clear_is_wheel_spd_fl_valid() {
  is_wheel_spd_fl_valid_ = false;
  clear_has_is_wheel_spd_fl_valid();
}
inline bool VehicleSpd::is_wheel_spd_fl_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.is_wheel_spd_fl_valid)
  return is_wheel_spd_fl_valid_;
}
inline void VehicleSpd::set_is_wheel_spd_fl_valid(bool value) {
  set_has_is_wheel_spd_fl_valid();
  is_wheel_spd_fl_valid_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.is_wheel_spd_fl_valid)
}

// optional .apollo.canbus.VehicleSpd.Type wheel_direction_fl = 14;
inline bool VehicleSpd::has_wheel_direction_fl() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void VehicleSpd::set_has_wheel_direction_fl() {
  _has_bits_[0] |= 0x00000800u;
}
inline void VehicleSpd::clear_has_wheel_direction_fl() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void VehicleSpd::clear_wheel_direction_fl() {
  wheel_direction_fl_ = 0;
  clear_has_wheel_direction_fl();
}
inline ::apollo::canbus::VehicleSpd_Type VehicleSpd::wheel_direction_fl() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.wheel_direction_fl)
  return static_cast< ::apollo::canbus::VehicleSpd_Type >(wheel_direction_fl_);
}
inline void VehicleSpd::set_wheel_direction_fl(::apollo::canbus::VehicleSpd_Type value) {
  assert(::apollo::canbus::VehicleSpd_Type_IsValid(value));
  set_has_wheel_direction_fl();
  wheel_direction_fl_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.wheel_direction_fl)
}

// optional double wheel_spd_fl = 15;
inline bool VehicleSpd::has_wheel_spd_fl() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void VehicleSpd::set_has_wheel_spd_fl() {
  _has_bits_[0] |= 0x00010000u;
}
inline void VehicleSpd::clear_has_wheel_spd_fl() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void VehicleSpd::clear_wheel_spd_fl() {
  wheel_spd_fl_ = 0;
  clear_has_wheel_spd_fl();
}
inline double VehicleSpd::wheel_spd_fl() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.wheel_spd_fl)
  return wheel_spd_fl_;
}
inline void VehicleSpd::set_wheel_spd_fl(double value) {
  set_has_wheel_spd_fl();
  wheel_spd_fl_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.wheel_spd_fl)
}

// optional bool is_yaw_rate_valid = 16;
inline bool VehicleSpd::has_is_yaw_rate_valid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void VehicleSpd::set_has_is_yaw_rate_valid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void VehicleSpd::clear_has_is_yaw_rate_valid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void VehicleSpd::clear_is_yaw_rate_valid() {
  is_yaw_rate_valid_ = false;
  clear_has_is_yaw_rate_valid();
}
inline bool VehicleSpd::is_yaw_rate_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.is_yaw_rate_valid)
  return is_yaw_rate_valid_;
}
inline void VehicleSpd::set_is_yaw_rate_valid(bool value) {
  set_has_is_yaw_rate_valid();
  is_yaw_rate_valid_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.is_yaw_rate_valid)
}

// optional double yaw_rate = 17;
inline bool VehicleSpd::has_yaw_rate() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void VehicleSpd::set_has_yaw_rate() {
  _has_bits_[0] |= 0x00020000u;
}
inline void VehicleSpd::clear_has_yaw_rate() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void VehicleSpd::clear_yaw_rate() {
  yaw_rate_ = 0;
  clear_has_yaw_rate();
}
inline double VehicleSpd::yaw_rate() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.yaw_rate)
  return yaw_rate_;
}
inline void VehicleSpd::set_yaw_rate(double value) {
  set_has_yaw_rate();
  yaw_rate_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.yaw_rate)
}

// optional double yaw_rate_offset = 18;
inline bool VehicleSpd::has_yaw_rate_offset() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void VehicleSpd::set_has_yaw_rate_offset() {
  _has_bits_[0] |= 0x00040000u;
}
inline void VehicleSpd::clear_has_yaw_rate_offset() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void VehicleSpd::clear_yaw_rate_offset() {
  yaw_rate_offset_ = 0;
  clear_has_yaw_rate_offset();
}
inline double VehicleSpd::yaw_rate_offset() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.yaw_rate_offset)
  return yaw_rate_offset_;
}
inline void VehicleSpd::set_yaw_rate_offset(double value) {
  set_has_yaw_rate_offset();
  yaw_rate_offset_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.yaw_rate_offset)
}

// optional bool is_ax_valid = 19;
inline bool VehicleSpd::has_is_ax_valid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void VehicleSpd::set_has_is_ax_valid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void VehicleSpd::clear_has_is_ax_valid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void VehicleSpd::clear_is_ax_valid() {
  is_ax_valid_ = false;
  clear_has_is_ax_valid();
}
inline bool VehicleSpd::is_ax_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.is_ax_valid)
  return is_ax_valid_;
}
inline void VehicleSpd::set_is_ax_valid(bool value) {
  set_has_is_ax_valid();
  is_ax_valid_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.is_ax_valid)
}

// optional double ax = 20;
inline bool VehicleSpd::has_ax() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void VehicleSpd::set_has_ax() {
  _has_bits_[0] |= 0x00080000u;
}
inline void VehicleSpd::clear_has_ax() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void VehicleSpd::clear_ax() {
  ax_ = 0;
  clear_has_ax();
}
inline double VehicleSpd::ax() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.ax)
  return ax_;
}
inline void VehicleSpd::set_ax(double value) {
  set_has_ax();
  ax_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.ax)
}

// optional double ax_offset = 21;
inline bool VehicleSpd::has_ax_offset() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void VehicleSpd::set_has_ax_offset() {
  _has_bits_[0] |= 0x00100000u;
}
inline void VehicleSpd::clear_has_ax_offset() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void VehicleSpd::clear_ax_offset() {
  ax_offset_ = 0;
  clear_has_ax_offset();
}
inline double VehicleSpd::ax_offset() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.ax_offset)
  return ax_offset_;
}
inline void VehicleSpd::set_ax_offset(double value) {
  set_has_ax_offset();
  ax_offset_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.ax_offset)
}

// optional bool is_ay_valid = 22;
inline bool VehicleSpd::has_is_ay_valid() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void VehicleSpd::set_has_is_ay_valid() {
  _has_bits_[0] |= 0x20000000u;
}
inline void VehicleSpd::clear_has_is_ay_valid() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void VehicleSpd::clear_is_ay_valid() {
  is_ay_valid_ = false;
  clear_has_is_ay_valid();
}
inline bool VehicleSpd::is_ay_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.is_ay_valid)
  return is_ay_valid_;
}
inline void VehicleSpd::set_is_ay_valid(bool value) {
  set_has_is_ay_valid();
  is_ay_valid_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.is_ay_valid)
}

// optional double ay = 23;
inline bool VehicleSpd::has_ay() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void VehicleSpd::set_has_ay() {
  _has_bits_[0] |= 0x00200000u;
}
inline void VehicleSpd::clear_has_ay() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void VehicleSpd::clear_ay() {
  ay_ = 0;
  clear_has_ay();
}
inline double VehicleSpd::ay() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.ay)
  return ay_;
}
inline void VehicleSpd::set_ay(double value) {
  set_has_ay();
  ay_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.ay)
}

// optional double ay_offset = 24;
inline bool VehicleSpd::has_ay_offset() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void VehicleSpd::set_has_ay_offset() {
  _has_bits_[0] |= 0x00400000u;
}
inline void VehicleSpd::clear_has_ay_offset() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void VehicleSpd::clear_ay_offset() {
  ay_offset_ = 0;
  clear_has_ay_offset();
}
inline double VehicleSpd::ay_offset() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.ay_offset)
  return ay_offset_;
}
inline void VehicleSpd::set_ay_offset(double value) {
  set_has_ay_offset();
  ay_offset_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.ay_offset)
}

// optional double lat_acc = 25;
inline bool VehicleSpd::has_lat_acc() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void VehicleSpd::set_has_lat_acc() {
  _has_bits_[0] |= 0x00800000u;
}
inline void VehicleSpd::clear_has_lat_acc() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void VehicleSpd::clear_lat_acc() {
  lat_acc_ = 0;
  clear_has_lat_acc();
}
inline double VehicleSpd::lat_acc() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.lat_acc)
  return lat_acc_;
}
inline void VehicleSpd::set_lat_acc(double value) {
  set_has_lat_acc();
  lat_acc_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.lat_acc)
}

// optional double long_acc = 26;
inline bool VehicleSpd::has_long_acc() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void VehicleSpd::set_has_long_acc() {
  _has_bits_[0] |= 0x01000000u;
}
inline void VehicleSpd::clear_has_long_acc() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void VehicleSpd::clear_long_acc() {
  long_acc_ = 0;
  clear_has_long_acc();
}
inline double VehicleSpd::long_acc() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.long_acc)
  return long_acc_;
}
inline void VehicleSpd::set_long_acc(double value) {
  set_has_long_acc();
  long_acc_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.long_acc)
}

// optional double vert_acc = 27;
inline bool VehicleSpd::has_vert_acc() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void VehicleSpd::set_has_vert_acc() {
  _has_bits_[0] |= 0x02000000u;
}
inline void VehicleSpd::clear_has_vert_acc() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void VehicleSpd::clear_vert_acc() {
  vert_acc_ = 0;
  clear_has_vert_acc();
}
inline double VehicleSpd::vert_acc() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.vert_acc)
  return vert_acc_;
}
inline void VehicleSpd::set_vert_acc(double value) {
  set_has_vert_acc();
  vert_acc_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.vert_acc)
}

// optional double roll_rate = 28;
inline bool VehicleSpd::has_roll_rate() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void VehicleSpd::set_has_roll_rate() {
  _has_bits_[0] |= 0x04000000u;
}
inline void VehicleSpd::clear_has_roll_rate() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void VehicleSpd::clear_roll_rate() {
  roll_rate_ = 0;
  clear_has_roll_rate();
}
inline double VehicleSpd::roll_rate() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.roll_rate)
  return roll_rate_;
}
inline void VehicleSpd::set_roll_rate(double value) {
  set_has_roll_rate();
  roll_rate_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.roll_rate)
}

// optional double acc_est = 29;
inline bool VehicleSpd::has_acc_est() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void VehicleSpd::set_has_acc_est() {
  _has_bits_[0] |= 0x08000000u;
}
inline void VehicleSpd::clear_has_acc_est() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void VehicleSpd::clear_acc_est() {
  acc_est_ = 0;
  clear_has_acc_est();
}
inline double VehicleSpd::acc_est() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.acc_est)
  return acc_est_;
}
inline void VehicleSpd::set_acc_est(double value) {
  set_has_acc_est();
  acc_est_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.acc_est)
}

// optional double timestamp_sec = 30;
inline bool VehicleSpd::has_timestamp_sec() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void VehicleSpd::set_has_timestamp_sec() {
  _has_bits_[0] |= 0x10000000u;
}
inline void VehicleSpd::clear_has_timestamp_sec() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void VehicleSpd::clear_timestamp_sec() {
  timestamp_sec_ = 0;
  clear_has_timestamp_sec();
}
inline double VehicleSpd::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.VehicleSpd.timestamp_sec)
  return timestamp_sec_;
}
inline void VehicleSpd::set_timestamp_sec(double value) {
  set_has_timestamp_sec();
  timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.VehicleSpd.timestamp_sec)
}

// -------------------------------------------------------------------

// Deceleration

// optional bool is_deceleration_available = 1;
inline bool Deceleration::has_is_deceleration_available() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Deceleration::set_has_is_deceleration_available() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Deceleration::clear_has_is_deceleration_available() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Deceleration::clear_is_deceleration_available() {
  is_deceleration_available_ = false;
  clear_has_is_deceleration_available();
}
inline bool Deceleration::is_deceleration_available() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Deceleration.is_deceleration_available)
  return is_deceleration_available_;
}
inline void Deceleration::set_is_deceleration_available(bool value) {
  set_has_is_deceleration_available();
  is_deceleration_available_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Deceleration.is_deceleration_available)
}

// optional bool is_deceleration_active = 2;
inline bool Deceleration::has_is_deceleration_active() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Deceleration::set_has_is_deceleration_active() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Deceleration::clear_has_is_deceleration_active() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Deceleration::clear_is_deceleration_active() {
  is_deceleration_active_ = false;
  clear_has_is_deceleration_active();
}
inline bool Deceleration::is_deceleration_active() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Deceleration.is_deceleration_active)
  return is_deceleration_active_;
}
inline void Deceleration::set_is_deceleration_active(bool value) {
  set_has_is_deceleration_active();
  is_deceleration_active_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Deceleration.is_deceleration_active)
}

// optional double deceleration = 3 [default = 0];
inline bool Deceleration::has_deceleration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Deceleration::set_has_deceleration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Deceleration::clear_has_deceleration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Deceleration::clear_deceleration() {
  deceleration_ = 0;
  clear_has_deceleration();
}
inline double Deceleration::deceleration() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Deceleration.deceleration)
  return deceleration_;
}
inline void Deceleration::set_deceleration(double value) {
  set_has_deceleration();
  deceleration_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Deceleration.deceleration)
}

// optional double is_evb_fail = 4;
inline bool Deceleration::has_is_evb_fail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Deceleration::set_has_is_evb_fail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Deceleration::clear_has_is_evb_fail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Deceleration::clear_is_evb_fail() {
  is_evb_fail_ = 0;
  clear_has_is_evb_fail();
}
inline double Deceleration::is_evb_fail() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Deceleration.is_evb_fail)
  return is_evb_fail_;
}
inline void Deceleration::set_is_evb_fail(double value) {
  set_has_is_evb_fail();
  is_evb_fail_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Deceleration.is_evb_fail)
}

// optional double evb_pressure = 5 [default = 0];
inline bool Deceleration::has_evb_pressure() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Deceleration::set_has_evb_pressure() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Deceleration::clear_has_evb_pressure() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Deceleration::clear_evb_pressure() {
  evb_pressure_ = 0;
  clear_has_evb_pressure();
}
inline double Deceleration::evb_pressure() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Deceleration.evb_pressure)
  return evb_pressure_;
}
inline void Deceleration::set_evb_pressure(double value) {
  set_has_evb_pressure();
  evb_pressure_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Deceleration.evb_pressure)
}

// optional double brake_pressure = 6 [default = 0];
inline bool Deceleration::has_brake_pressure() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Deceleration::set_has_brake_pressure() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Deceleration::clear_has_brake_pressure() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Deceleration::clear_brake_pressure() {
  brake_pressure_ = 0;
  clear_has_brake_pressure();
}
inline double Deceleration::brake_pressure() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Deceleration.brake_pressure)
  return brake_pressure_;
}
inline void Deceleration::set_brake_pressure(double value) {
  set_has_brake_pressure();
  brake_pressure_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Deceleration.brake_pressure)
}

// optional double brake_pressure_spd = 7 [default = 0];
inline bool Deceleration::has_brake_pressure_spd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Deceleration::set_has_brake_pressure_spd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Deceleration::clear_has_brake_pressure_spd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Deceleration::clear_brake_pressure_spd() {
  brake_pressure_spd_ = 0;
  clear_has_brake_pressure_spd();
}
inline double Deceleration::brake_pressure_spd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Deceleration.brake_pressure_spd)
  return brake_pressure_spd_;
}
inline void Deceleration::set_brake_pressure_spd(double value) {
  set_has_brake_pressure_spd();
  brake_pressure_spd_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Deceleration.brake_pressure_spd)
}

// -------------------------------------------------------------------

// Brake

// optional bool is_brake_pedal_pressed = 1 [default = false];
inline bool Brake::has_is_brake_pedal_pressed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Brake::set_has_is_brake_pedal_pressed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Brake::clear_has_is_brake_pedal_pressed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Brake::clear_is_brake_pedal_pressed() {
  is_brake_pedal_pressed_ = false;
  clear_has_is_brake_pedal_pressed();
}
inline bool Brake::is_brake_pedal_pressed() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.is_brake_pedal_pressed)
  return is_brake_pedal_pressed_;
}
inline void Brake::set_is_brake_pedal_pressed(bool value) {
  set_has_is_brake_pedal_pressed();
  is_brake_pedal_pressed_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.is_brake_pedal_pressed)
}

// optional bool is_brake_force_exist = 2;
inline bool Brake::has_is_brake_force_exist() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Brake::set_has_is_brake_force_exist() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Brake::clear_has_is_brake_force_exist() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Brake::clear_is_brake_force_exist() {
  is_brake_force_exist_ = false;
  clear_has_is_brake_force_exist();
}
inline bool Brake::is_brake_force_exist() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.is_brake_force_exist)
  return is_brake_force_exist_;
}
inline void Brake::set_is_brake_force_exist(bool value) {
  set_has_is_brake_force_exist();
  is_brake_force_exist_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.is_brake_force_exist)
}

// optional bool is_brake_over_heat = 3;
inline bool Brake::has_is_brake_over_heat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Brake::set_has_is_brake_over_heat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Brake::clear_has_is_brake_over_heat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Brake::clear_is_brake_over_heat() {
  is_brake_over_heat_ = false;
  clear_has_is_brake_over_heat();
}
inline bool Brake::is_brake_over_heat() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.is_brake_over_heat)
  return is_brake_over_heat_;
}
inline void Brake::set_is_brake_over_heat(bool value) {
  set_has_is_brake_over_heat();
  is_brake_over_heat_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.is_brake_over_heat)
}

// optional bool is_hand_brake_on = 4;
inline bool Brake::has_is_hand_brake_on() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Brake::set_has_is_hand_brake_on() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Brake::clear_has_is_hand_brake_on() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Brake::clear_is_hand_brake_on() {
  is_hand_brake_on_ = false;
  clear_has_is_hand_brake_on();
}
inline bool Brake::is_hand_brake_on() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.is_hand_brake_on)
  return is_hand_brake_on_;
}
inline void Brake::set_is_hand_brake_on(bool value) {
  set_has_is_hand_brake_on();
  is_hand_brake_on_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.is_hand_brake_on)
}

// optional double brake_pedal_position = 5;
inline bool Brake::has_brake_pedal_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Brake::set_has_brake_pedal_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Brake::clear_has_brake_pedal_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Brake::clear_brake_pedal_position() {
  brake_pedal_position_ = 0;
  clear_has_brake_pedal_position();
}
inline double Brake::brake_pedal_position() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.brake_pedal_position)
  return brake_pedal_position_;
}
inline void Brake::set_brake_pedal_position(double value) {
  set_has_brake_pedal_position();
  brake_pedal_position_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.brake_pedal_position)
}

// optional bool is_brake_valid = 6;
inline bool Brake::has_is_brake_valid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Brake::set_has_is_brake_valid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Brake::clear_has_is_brake_valid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Brake::clear_is_brake_valid() {
  is_brake_valid_ = false;
  clear_has_is_brake_valid();
}
inline bool Brake::is_brake_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.is_brake_valid)
  return is_brake_valid_;
}
inline void Brake::set_is_brake_valid(bool value) {
  set_has_is_brake_valid();
  is_brake_valid_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.is_brake_valid)
}

// optional double brake_input = 7;
inline bool Brake::has_brake_input() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Brake::set_has_brake_input() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Brake::clear_has_brake_input() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Brake::clear_brake_input() {
  brake_input_ = 0;
  clear_has_brake_input();
}
inline double Brake::brake_input() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.brake_input)
  return brake_input_;
}
inline void Brake::set_brake_input(double value) {
  set_has_brake_input();
  brake_input_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.brake_input)
}

// optional double brake_cmd = 8;
inline bool Brake::has_brake_cmd() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Brake::set_has_brake_cmd() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Brake::clear_has_brake_cmd() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Brake::clear_brake_cmd() {
  brake_cmd_ = 0;
  clear_has_brake_cmd();
}
inline double Brake::brake_cmd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.brake_cmd)
  return brake_cmd_;
}
inline void Brake::set_brake_cmd(double value) {
  set_has_brake_cmd();
  brake_cmd_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.brake_cmd)
}

// optional double brake_output = 9;
inline bool Brake::has_brake_output() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Brake::set_has_brake_output() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Brake::clear_has_brake_output() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Brake::clear_brake_output() {
  brake_output_ = 0;
  clear_has_brake_output();
}
inline double Brake::brake_output() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.brake_output)
  return brake_output_;
}
inline void Brake::set_brake_output(double value) {
  set_has_brake_output();
  brake_output_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.brake_output)
}

// optional bool boo_input = 10;
inline bool Brake::has_boo_input() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Brake::set_has_boo_input() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Brake::clear_has_boo_input() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Brake::clear_boo_input() {
  boo_input_ = false;
  clear_has_boo_input();
}
inline bool Brake::boo_input() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.boo_input)
  return boo_input_;
}
inline void Brake::set_boo_input(bool value) {
  set_has_boo_input();
  boo_input_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.boo_input)
}

// optional bool boo_cmd = 11;
inline bool Brake::has_boo_cmd() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Brake::set_has_boo_cmd() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Brake::clear_has_boo_cmd() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Brake::clear_boo_cmd() {
  boo_cmd_ = false;
  clear_has_boo_cmd();
}
inline bool Brake::boo_cmd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.boo_cmd)
  return boo_cmd_;
}
inline void Brake::set_boo_cmd(bool value) {
  set_has_boo_cmd();
  boo_cmd_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.boo_cmd)
}

// optional bool boo_output = 12;
inline bool Brake::has_boo_output() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Brake::set_has_boo_output() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Brake::clear_has_boo_output() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Brake::clear_boo_output() {
  boo_output_ = false;
  clear_has_boo_output();
}
inline bool Brake::boo_output() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.boo_output)
  return boo_output_;
}
inline void Brake::set_boo_output(bool value) {
  set_has_boo_output();
  boo_output_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.boo_output)
}

// optional bool watchdog_applying_brakes = 13;
inline bool Brake::has_watchdog_applying_brakes() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Brake::set_has_watchdog_applying_brakes() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Brake::clear_has_watchdog_applying_brakes() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Brake::clear_watchdog_applying_brakes() {
  watchdog_applying_brakes_ = false;
  clear_has_watchdog_applying_brakes();
}
inline bool Brake::watchdog_applying_brakes() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.watchdog_applying_brakes)
  return watchdog_applying_brakes_;
}
inline void Brake::set_watchdog_applying_brakes(bool value) {
  set_has_watchdog_applying_brakes();
  watchdog_applying_brakes_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.watchdog_applying_brakes)
}

// optional int32 watchdog_source = 14;
inline bool Brake::has_watchdog_source() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Brake::set_has_watchdog_source() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Brake::clear_has_watchdog_source() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Brake::clear_watchdog_source() {
  watchdog_source_ = 0;
  clear_has_watchdog_source();
}
inline ::google::protobuf::int32 Brake::watchdog_source() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.watchdog_source)
  return watchdog_source_;
}
inline void Brake::set_watchdog_source(::google::protobuf::int32 value) {
  set_has_watchdog_source();
  watchdog_source_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.watchdog_source)
}

// optional bool brake_enabled = 15;
inline bool Brake::has_brake_enabled() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Brake::set_has_brake_enabled() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Brake::clear_has_brake_enabled() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Brake::clear_brake_enabled() {
  brake_enabled_ = false;
  clear_has_brake_enabled();
}
inline bool Brake::brake_enabled() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.brake_enabled)
  return brake_enabled_;
}
inline void Brake::set_brake_enabled(bool value) {
  set_has_brake_enabled();
  brake_enabled_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.brake_enabled)
}

// optional bool driver_override = 16;
inline bool Brake::has_driver_override() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Brake::set_has_driver_override() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Brake::clear_has_driver_override() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Brake::clear_driver_override() {
  driver_override_ = false;
  clear_has_driver_override();
}
inline bool Brake::driver_override() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.driver_override)
  return driver_override_;
}
inline void Brake::set_driver_override(bool value) {
  set_has_driver_override();
  driver_override_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.driver_override)
}

// optional bool driver_activity = 17;
inline bool Brake::has_driver_activity() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Brake::set_has_driver_activity() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Brake::clear_has_driver_activity() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Brake::clear_driver_activity() {
  driver_activity_ = false;
  clear_has_driver_activity();
}
inline bool Brake::driver_activity() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.driver_activity)
  return driver_activity_;
}
inline void Brake::set_driver_activity(bool value) {
  set_has_driver_activity();
  driver_activity_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.driver_activity)
}

// optional bool watchdog_fault = 18;
inline bool Brake::has_watchdog_fault() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Brake::set_has_watchdog_fault() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Brake::clear_has_watchdog_fault() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Brake::clear_watchdog_fault() {
  watchdog_fault_ = false;
  clear_has_watchdog_fault();
}
inline bool Brake::watchdog_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.watchdog_fault)
  return watchdog_fault_;
}
inline void Brake::set_watchdog_fault(bool value) {
  set_has_watchdog_fault();
  watchdog_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.watchdog_fault)
}

// optional bool channel_1_fault = 19;
inline bool Brake::has_channel_1_fault() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Brake::set_has_channel_1_fault() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Brake::clear_has_channel_1_fault() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Brake::clear_channel_1_fault() {
  channel_1_fault_ = false;
  clear_has_channel_1_fault();
}
inline bool Brake::channel_1_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.channel_1_fault)
  return channel_1_fault_;
}
inline void Brake::set_channel_1_fault(bool value) {
  set_has_channel_1_fault();
  channel_1_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.channel_1_fault)
}

// optional bool channel_2_fault = 20;
inline bool Brake::has_channel_2_fault() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Brake::set_has_channel_2_fault() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Brake::clear_has_channel_2_fault() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Brake::clear_channel_2_fault() {
  channel_2_fault_ = false;
  clear_has_channel_2_fault();
}
inline bool Brake::channel_2_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.channel_2_fault)
  return channel_2_fault_;
}
inline void Brake::set_channel_2_fault(bool value) {
  set_has_channel_2_fault();
  channel_2_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.channel_2_fault)
}

// optional bool boo_fault = 21;
inline bool Brake::has_boo_fault() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Brake::set_has_boo_fault() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Brake::clear_has_boo_fault() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Brake::clear_boo_fault() {
  boo_fault_ = false;
  clear_has_boo_fault();
}
inline bool Brake::boo_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.boo_fault)
  return boo_fault_;
}
inline void Brake::set_boo_fault(bool value) {
  set_has_boo_fault();
  boo_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.boo_fault)
}

// optional bool connector_fault = 22;
inline bool Brake::has_connector_fault() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Brake::set_has_connector_fault() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Brake::clear_has_connector_fault() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Brake::clear_connector_fault() {
  connector_fault_ = false;
  clear_has_connector_fault();
}
inline bool Brake::connector_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.connector_fault)
  return connector_fault_;
}
inline void Brake::set_connector_fault(bool value) {
  set_has_connector_fault();
  connector_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.connector_fault)
}

// optional double brake_torque_req = 23;
inline bool Brake::has_brake_torque_req() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Brake::set_has_brake_torque_req() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Brake::clear_has_brake_torque_req() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Brake::clear_brake_torque_req() {
  brake_torque_req_ = 0;
  clear_has_brake_torque_req();
}
inline double Brake::brake_torque_req() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.brake_torque_req)
  return brake_torque_req_;
}
inline void Brake::set_brake_torque_req(double value) {
  set_has_brake_torque_req();
  brake_torque_req_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.brake_torque_req)
}

// optional .apollo.canbus.Brake.HSAStatusType hsa_status = 24;
inline bool Brake::has_hsa_status() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Brake::set_has_hsa_status() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Brake::clear_has_hsa_status() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Brake::clear_hsa_status() {
  hsa_status_ = 0;
  clear_has_hsa_status();
}
inline ::apollo::canbus::Brake_HSAStatusType Brake::hsa_status() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.hsa_status)
  return static_cast< ::apollo::canbus::Brake_HSAStatusType >(hsa_status_);
}
inline void Brake::set_hsa_status(::apollo::canbus::Brake_HSAStatusType value) {
  assert(::apollo::canbus::Brake_HSAStatusType_IsValid(value));
  set_has_hsa_status();
  hsa_status_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.hsa_status)
}

// optional double brake_torque_act = 25;
inline bool Brake::has_brake_torque_act() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Brake::set_has_brake_torque_act() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Brake::clear_has_brake_torque_act() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Brake::clear_brake_torque_act() {
  brake_torque_act_ = 0;
  clear_has_brake_torque_act();
}
inline double Brake::brake_torque_act() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.brake_torque_act)
  return brake_torque_act_;
}
inline void Brake::set_brake_torque_act(double value) {
  set_has_brake_torque_act();
  brake_torque_act_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.brake_torque_act)
}

// optional .apollo.canbus.Brake.HSAModeType hsa_mode = 26;
inline bool Brake::has_hsa_mode() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Brake::set_has_hsa_mode() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Brake::clear_has_hsa_mode() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Brake::clear_hsa_mode() {
  hsa_mode_ = 0;
  clear_has_hsa_mode();
}
inline ::apollo::canbus::Brake_HSAModeType Brake::hsa_mode() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.hsa_mode)
  return static_cast< ::apollo::canbus::Brake_HSAModeType >(hsa_mode_);
}
inline void Brake::set_hsa_mode(::apollo::canbus::Brake_HSAModeType value) {
  assert(::apollo::canbus::Brake_HSAModeType_IsValid(value));
  set_has_hsa_mode();
  hsa_mode_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.hsa_mode)
}

// optional double wheel_torque_act = 27;
inline bool Brake::has_wheel_torque_act() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Brake::set_has_wheel_torque_act() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Brake::clear_has_wheel_torque_act() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Brake::clear_wheel_torque_act() {
  wheel_torque_act_ = 0;
  clear_has_wheel_torque_act();
}
inline double Brake::wheel_torque_act() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.wheel_torque_act)
  return wheel_torque_act_;
}
inline void Brake::set_wheel_torque_act(double value) {
  set_has_wheel_torque_act();
  wheel_torque_act_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.wheel_torque_act)
}

// optional int32 major_version = 28;
inline bool Brake::has_major_version() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Brake::set_has_major_version() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Brake::clear_has_major_version() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Brake::clear_major_version() {
  major_version_ = 0;
  clear_has_major_version();
}
inline ::google::protobuf::int32 Brake::major_version() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.major_version)
  return major_version_;
}
inline void Brake::set_major_version(::google::protobuf::int32 value) {
  set_has_major_version();
  major_version_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.major_version)
}

// optional int32 minor_version = 29;
inline bool Brake::has_minor_version() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Brake::set_has_minor_version() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Brake::clear_has_minor_version() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Brake::clear_minor_version() {
  minor_version_ = 0;
  clear_has_minor_version();
}
inline ::google::protobuf::int32 Brake::minor_version() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.minor_version)
  return minor_version_;
}
inline void Brake::set_minor_version(::google::protobuf::int32 value) {
  set_has_minor_version();
  minor_version_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.minor_version)
}

// optional int32 build_number = 30;
inline bool Brake::has_build_number() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Brake::set_has_build_number() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Brake::clear_has_build_number() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Brake::clear_build_number() {
  build_number_ = 0;
  clear_has_build_number();
}
inline ::google::protobuf::int32 Brake::build_number() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake.build_number)
  return build_number_;
}
inline void Brake::set_build_number(::google::protobuf::int32 value) {
  set_has_build_number();
  build_number_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake.build_number)
}

// -------------------------------------------------------------------

// Epb

// optional bool is_epb_error = 1;
inline bool Epb::has_is_epb_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Epb::set_has_is_epb_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Epb::clear_has_is_epb_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Epb::clear_is_epb_error() {
  is_epb_error_ = false;
  clear_has_is_epb_error();
}
inline bool Epb::is_epb_error() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Epb.is_epb_error)
  return is_epb_error_;
}
inline void Epb::set_is_epb_error(bool value) {
  set_has_is_epb_error();
  is_epb_error_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Epb.is_epb_error)
}

// optional bool is_epb_released = 2;
inline bool Epb::has_is_epb_released() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Epb::set_has_is_epb_released() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Epb::clear_has_is_epb_released() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Epb::clear_is_epb_released() {
  is_epb_released_ = false;
  clear_has_is_epb_released();
}
inline bool Epb::is_epb_released() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Epb.is_epb_released)
  return is_epb_released_;
}
inline void Epb::set_is_epb_released(bool value) {
  set_has_is_epb_released();
  is_epb_released_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Epb.is_epb_released)
}

// optional int32 epb_status = 3;
inline bool Epb::has_epb_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Epb::set_has_epb_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Epb::clear_has_epb_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Epb::clear_epb_status() {
  epb_status_ = 0;
  clear_has_epb_status();
}
inline ::google::protobuf::int32 Epb::epb_status() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Epb.epb_status)
  return epb_status_;
}
inline void Epb::set_epb_status(::google::protobuf::int32 value) {
  set_has_epb_status();
  epb_status_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Epb.epb_status)
}

// optional .apollo.canbus.Epb.PBrakeType parking_brake_status = 4;
inline bool Epb::has_parking_brake_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Epb::set_has_parking_brake_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Epb::clear_has_parking_brake_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Epb::clear_parking_brake_status() {
  parking_brake_status_ = 0;
  clear_has_parking_brake_status();
}
inline ::apollo::canbus::Epb_PBrakeType Epb::parking_brake_status() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Epb.parking_brake_status)
  return static_cast< ::apollo::canbus::Epb_PBrakeType >(parking_brake_status_);
}
inline void Epb::set_parking_brake_status(::apollo::canbus::Epb_PBrakeType value) {
  assert(::apollo::canbus::Epb_PBrakeType_IsValid(value));
  set_has_parking_brake_status();
  parking_brake_status_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Epb.parking_brake_status)
}

// -------------------------------------------------------------------

// Gas

// optional bool is_gas_pedal_error = 1;
inline bool Gas::has_is_gas_pedal_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Gas::set_has_is_gas_pedal_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Gas::clear_has_is_gas_pedal_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Gas::clear_is_gas_pedal_error() {
  is_gas_pedal_error_ = false;
  clear_has_is_gas_pedal_error();
}
inline bool Gas::is_gas_pedal_error() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.is_gas_pedal_error)
  return is_gas_pedal_error_;
}
inline void Gas::set_is_gas_pedal_error(bool value) {
  set_has_is_gas_pedal_error();
  is_gas_pedal_error_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.is_gas_pedal_error)
}

// optional bool is_gas_pedal_pressed_more = 2;
inline bool Gas::has_is_gas_pedal_pressed_more() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Gas::set_has_is_gas_pedal_pressed_more() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Gas::clear_has_is_gas_pedal_pressed_more() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Gas::clear_is_gas_pedal_pressed_more() {
  is_gas_pedal_pressed_more_ = false;
  clear_has_is_gas_pedal_pressed_more();
}
inline bool Gas::is_gas_pedal_pressed_more() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.is_gas_pedal_pressed_more)
  return is_gas_pedal_pressed_more_;
}
inline void Gas::set_is_gas_pedal_pressed_more(bool value) {
  set_has_is_gas_pedal_pressed_more();
  is_gas_pedal_pressed_more_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.is_gas_pedal_pressed_more)
}

// optional double gas_pedal_position = 3 [default = 0];
inline bool Gas::has_gas_pedal_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Gas::set_has_gas_pedal_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Gas::clear_has_gas_pedal_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Gas::clear_gas_pedal_position() {
  gas_pedal_position_ = 0;
  clear_has_gas_pedal_position();
}
inline double Gas::gas_pedal_position() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.gas_pedal_position)
  return gas_pedal_position_;
}
inline void Gas::set_gas_pedal_position(double value) {
  set_has_gas_pedal_position();
  gas_pedal_position_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.gas_pedal_position)
}

// optional bool is_gas_valid = 4 [default = false];
inline bool Gas::has_is_gas_valid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Gas::set_has_is_gas_valid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Gas::clear_has_is_gas_valid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Gas::clear_is_gas_valid() {
  is_gas_valid_ = false;
  clear_has_is_gas_valid();
}
inline bool Gas::is_gas_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.is_gas_valid)
  return is_gas_valid_;
}
inline void Gas::set_is_gas_valid(bool value) {
  set_has_is_gas_valid();
  is_gas_valid_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.is_gas_valid)
}

// optional double throttle_input = 5;
inline bool Gas::has_throttle_input() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Gas::set_has_throttle_input() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Gas::clear_has_throttle_input() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Gas::clear_throttle_input() {
  throttle_input_ = 0;
  clear_has_throttle_input();
}
inline double Gas::throttle_input() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.throttle_input)
  return throttle_input_;
}
inline void Gas::set_throttle_input(double value) {
  set_has_throttle_input();
  throttle_input_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.throttle_input)
}

// optional double throttle_cmd = 6;
inline bool Gas::has_throttle_cmd() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Gas::set_has_throttle_cmd() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Gas::clear_has_throttle_cmd() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Gas::clear_throttle_cmd() {
  throttle_cmd_ = 0;
  clear_has_throttle_cmd();
}
inline double Gas::throttle_cmd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.throttle_cmd)
  return throttle_cmd_;
}
inline void Gas::set_throttle_cmd(double value) {
  set_has_throttle_cmd();
  throttle_cmd_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.throttle_cmd)
}

// optional double throttle_output = 7;
inline bool Gas::has_throttle_output() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Gas::set_has_throttle_output() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Gas::clear_has_throttle_output() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Gas::clear_throttle_output() {
  throttle_output_ = 0;
  clear_has_throttle_output();
}
inline double Gas::throttle_output() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.throttle_output)
  return throttle_output_;
}
inline void Gas::set_throttle_output(double value) {
  set_has_throttle_output();
  throttle_output_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.throttle_output)
}

// optional int32 watchdog_source = 8;
inline bool Gas::has_watchdog_source() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Gas::set_has_watchdog_source() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Gas::clear_has_watchdog_source() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Gas::clear_watchdog_source() {
  watchdog_source_ = 0;
  clear_has_watchdog_source();
}
inline ::google::protobuf::int32 Gas::watchdog_source() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.watchdog_source)
  return watchdog_source_;
}
inline void Gas::set_watchdog_source(::google::protobuf::int32 value) {
  set_has_watchdog_source();
  watchdog_source_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.watchdog_source)
}

// optional bool throttle_enabled = 9;
inline bool Gas::has_throttle_enabled() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Gas::set_has_throttle_enabled() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Gas::clear_has_throttle_enabled() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Gas::clear_throttle_enabled() {
  throttle_enabled_ = false;
  clear_has_throttle_enabled();
}
inline bool Gas::throttle_enabled() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.throttle_enabled)
  return throttle_enabled_;
}
inline void Gas::set_throttle_enabled(bool value) {
  set_has_throttle_enabled();
  throttle_enabled_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.throttle_enabled)
}

// optional bool driver_override = 10;
inline bool Gas::has_driver_override() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Gas::set_has_driver_override() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Gas::clear_has_driver_override() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Gas::clear_driver_override() {
  driver_override_ = false;
  clear_has_driver_override();
}
inline bool Gas::driver_override() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.driver_override)
  return driver_override_;
}
inline void Gas::set_driver_override(bool value) {
  set_has_driver_override();
  driver_override_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.driver_override)
}

// optional bool driver_activity = 11;
inline bool Gas::has_driver_activity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Gas::set_has_driver_activity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Gas::clear_has_driver_activity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Gas::clear_driver_activity() {
  driver_activity_ = false;
  clear_has_driver_activity();
}
inline bool Gas::driver_activity() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.driver_activity)
  return driver_activity_;
}
inline void Gas::set_driver_activity(bool value) {
  set_has_driver_activity();
  driver_activity_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.driver_activity)
}

// optional bool watchdog_fault = 12;
inline bool Gas::has_watchdog_fault() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Gas::set_has_watchdog_fault() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Gas::clear_has_watchdog_fault() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Gas::clear_watchdog_fault() {
  watchdog_fault_ = false;
  clear_has_watchdog_fault();
}
inline bool Gas::watchdog_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.watchdog_fault)
  return watchdog_fault_;
}
inline void Gas::set_watchdog_fault(bool value) {
  set_has_watchdog_fault();
  watchdog_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.watchdog_fault)
}

// optional bool channel_1_fault = 13;
inline bool Gas::has_channel_1_fault() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Gas::set_has_channel_1_fault() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Gas::clear_has_channel_1_fault() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Gas::clear_channel_1_fault() {
  channel_1_fault_ = false;
  clear_has_channel_1_fault();
}
inline bool Gas::channel_1_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.channel_1_fault)
  return channel_1_fault_;
}
inline void Gas::set_channel_1_fault(bool value) {
  set_has_channel_1_fault();
  channel_1_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.channel_1_fault)
}

// optional bool channel_2_fault = 14;
inline bool Gas::has_channel_2_fault() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Gas::set_has_channel_2_fault() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Gas::clear_has_channel_2_fault() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Gas::clear_channel_2_fault() {
  channel_2_fault_ = false;
  clear_has_channel_2_fault();
}
inline bool Gas::channel_2_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.channel_2_fault)
  return channel_2_fault_;
}
inline void Gas::set_channel_2_fault(bool value) {
  set_has_channel_2_fault();
  channel_2_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.channel_2_fault)
}

// optional bool connector_fault = 15;
inline bool Gas::has_connector_fault() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Gas::set_has_connector_fault() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Gas::clear_has_connector_fault() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Gas::clear_connector_fault() {
  connector_fault_ = false;
  clear_has_connector_fault();
}
inline bool Gas::connector_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.connector_fault)
  return connector_fault_;
}
inline void Gas::set_connector_fault(bool value) {
  set_has_connector_fault();
  connector_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.connector_fault)
}

// optional double accelerator_pedal = 16;
inline bool Gas::has_accelerator_pedal() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Gas::set_has_accelerator_pedal() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Gas::clear_has_accelerator_pedal() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Gas::clear_accelerator_pedal() {
  accelerator_pedal_ = 0;
  clear_has_accelerator_pedal();
}
inline double Gas::accelerator_pedal() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.accelerator_pedal)
  return accelerator_pedal_;
}
inline void Gas::set_accelerator_pedal(double value) {
  set_has_accelerator_pedal();
  accelerator_pedal_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.accelerator_pedal)
}

// optional double accelerator_pedal_rate = 17;
inline bool Gas::has_accelerator_pedal_rate() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Gas::set_has_accelerator_pedal_rate() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Gas::clear_has_accelerator_pedal_rate() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Gas::clear_accelerator_pedal_rate() {
  accelerator_pedal_rate_ = 0;
  clear_has_accelerator_pedal_rate();
}
inline double Gas::accelerator_pedal_rate() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.accelerator_pedal_rate)
  return accelerator_pedal_rate_;
}
inline void Gas::set_accelerator_pedal_rate(double value) {
  set_has_accelerator_pedal_rate();
  accelerator_pedal_rate_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.accelerator_pedal_rate)
}

// optional int32 major_version = 18;
inline bool Gas::has_major_version() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Gas::set_has_major_version() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Gas::clear_has_major_version() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Gas::clear_major_version() {
  major_version_ = 0;
  clear_has_major_version();
}
inline ::google::protobuf::int32 Gas::major_version() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.major_version)
  return major_version_;
}
inline void Gas::set_major_version(::google::protobuf::int32 value) {
  set_has_major_version();
  major_version_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.major_version)
}

// optional int32 minor_version = 19;
inline bool Gas::has_minor_version() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Gas::set_has_minor_version() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Gas::clear_has_minor_version() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Gas::clear_minor_version() {
  minor_version_ = 0;
  clear_has_minor_version();
}
inline ::google::protobuf::int32 Gas::minor_version() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.minor_version)
  return minor_version_;
}
inline void Gas::set_minor_version(::google::protobuf::int32 value) {
  set_has_minor_version();
  minor_version_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.minor_version)
}

// optional int32 build_number = 20;
inline bool Gas::has_build_number() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Gas::set_has_build_number() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Gas::clear_has_build_number() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Gas::clear_build_number() {
  build_number_ = 0;
  clear_has_build_number();
}
inline ::google::protobuf::int32 Gas::build_number() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gas.build_number)
  return build_number_;
}
inline void Gas::set_build_number(::google::protobuf::int32 value) {
  set_has_build_number();
  build_number_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gas.build_number)
}

// -------------------------------------------------------------------

// Esp

// optional bool is_esp_acc_error = 1;
inline bool Esp::has_is_esp_acc_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Esp::set_has_is_esp_acc_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Esp::clear_has_is_esp_acc_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Esp::clear_is_esp_acc_error() {
  is_esp_acc_error_ = false;
  clear_has_is_esp_acc_error();
}
inline bool Esp::is_esp_acc_error() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_esp_acc_error)
  return is_esp_acc_error_;
}
inline void Esp::set_is_esp_acc_error(bool value) {
  set_has_is_esp_acc_error();
  is_esp_acc_error_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_esp_acc_error)
}

// optional bool is_esp_on = 2;
inline bool Esp::has_is_esp_on() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Esp::set_has_is_esp_on() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Esp::clear_has_is_esp_on() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Esp::clear_is_esp_on() {
  is_esp_on_ = false;
  clear_has_is_esp_on();
}
inline bool Esp::is_esp_on() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_esp_on)
  return is_esp_on_;
}
inline void Esp::set_is_esp_on(bool value) {
  set_has_is_esp_on();
  is_esp_on_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_esp_on)
}

// optional bool is_esp_active = 3;
inline bool Esp::has_is_esp_active() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Esp::set_has_is_esp_active() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Esp::clear_has_is_esp_active() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Esp::clear_is_esp_active() {
  is_esp_active_ = false;
  clear_has_is_esp_active();
}
inline bool Esp::is_esp_active() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_esp_active)
  return is_esp_active_;
}
inline void Esp::set_is_esp_active(bool value) {
  set_has_is_esp_active();
  is_esp_active_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_esp_active)
}

// optional bool is_abs_error = 4;
inline bool Esp::has_is_abs_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Esp::set_has_is_abs_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Esp::clear_has_is_abs_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Esp::clear_is_abs_error() {
  is_abs_error_ = false;
  clear_has_is_abs_error();
}
inline bool Esp::is_abs_error() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_abs_error)
  return is_abs_error_;
}
inline void Esp::set_is_abs_error(bool value) {
  set_has_is_abs_error();
  is_abs_error_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_abs_error)
}

// optional bool is_abs_active = 5;
inline bool Esp::has_is_abs_active() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Esp::set_has_is_abs_active() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Esp::clear_has_is_abs_active() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Esp::clear_is_abs_active() {
  is_abs_active_ = false;
  clear_has_is_abs_active();
}
inline bool Esp::is_abs_active() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_abs_active)
  return is_abs_active_;
}
inline void Esp::set_is_abs_active(bool value) {
  set_has_is_abs_active();
  is_abs_active_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_abs_active)
}

// optional bool is_tcsvdc_fail = 6;
inline bool Esp::has_is_tcsvdc_fail() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Esp::set_has_is_tcsvdc_fail() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Esp::clear_has_is_tcsvdc_fail() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Esp::clear_is_tcsvdc_fail() {
  is_tcsvdc_fail_ = false;
  clear_has_is_tcsvdc_fail();
}
inline bool Esp::is_tcsvdc_fail() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_tcsvdc_fail)
  return is_tcsvdc_fail_;
}
inline void Esp::set_is_tcsvdc_fail(bool value) {
  set_has_is_tcsvdc_fail();
  is_tcsvdc_fail_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_tcsvdc_fail)
}

// optional bool is_abs_enabled = 7;
inline bool Esp::has_is_abs_enabled() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Esp::set_has_is_abs_enabled() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Esp::clear_has_is_abs_enabled() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Esp::clear_is_abs_enabled() {
  is_abs_enabled_ = false;
  clear_has_is_abs_enabled();
}
inline bool Esp::is_abs_enabled() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_abs_enabled)
  return is_abs_enabled_;
}
inline void Esp::set_is_abs_enabled(bool value) {
  set_has_is_abs_enabled();
  is_abs_enabled_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_abs_enabled)
}

// optional bool is_stab_active = 8;
inline bool Esp::has_is_stab_active() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Esp::set_has_is_stab_active() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Esp::clear_has_is_stab_active() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Esp::clear_is_stab_active() {
  is_stab_active_ = false;
  clear_has_is_stab_active();
}
inline bool Esp::is_stab_active() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_stab_active)
  return is_stab_active_;
}
inline void Esp::set_is_stab_active(bool value) {
  set_has_is_stab_active();
  is_stab_active_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_stab_active)
}

// optional bool is_stab_enabled = 9;
inline bool Esp::has_is_stab_enabled() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Esp::set_has_is_stab_enabled() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Esp::clear_has_is_stab_enabled() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Esp::clear_is_stab_enabled() {
  is_stab_enabled_ = false;
  clear_has_is_stab_enabled();
}
inline bool Esp::is_stab_enabled() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_stab_enabled)
  return is_stab_enabled_;
}
inline void Esp::set_is_stab_enabled(bool value) {
  set_has_is_stab_enabled();
  is_stab_enabled_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_stab_enabled)
}

// optional bool is_trac_active = 10;
inline bool Esp::has_is_trac_active() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Esp::set_has_is_trac_active() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Esp::clear_has_is_trac_active() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Esp::clear_is_trac_active() {
  is_trac_active_ = false;
  clear_has_is_trac_active();
}
inline bool Esp::is_trac_active() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_trac_active)
  return is_trac_active_;
}
inline void Esp::set_is_trac_active(bool value) {
  set_has_is_trac_active();
  is_trac_active_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_trac_active)
}

// optional bool is_trac_enabled = 11;
inline bool Esp::has_is_trac_enabled() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Esp::set_has_is_trac_enabled() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Esp::clear_has_is_trac_enabled() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Esp::clear_is_trac_enabled() {
  is_trac_enabled_ = false;
  clear_has_is_trac_enabled();
}
inline bool Esp::is_trac_enabled() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Esp.is_trac_enabled)
  return is_trac_enabled_;
}
inline void Esp::set_is_trac_enabled(bool value) {
  set_has_is_trac_enabled();
  is_trac_enabled_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Esp.is_trac_enabled)
}

// -------------------------------------------------------------------

// Ems

// optional bool is_engine_acc_available = 1;
inline bool Ems::has_is_engine_acc_available() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ems::set_has_is_engine_acc_available() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ems::clear_has_is_engine_acc_available() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ems::clear_is_engine_acc_available() {
  is_engine_acc_available_ = false;
  clear_has_is_engine_acc_available();
}
inline bool Ems::is_engine_acc_available() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.is_engine_acc_available)
  return is_engine_acc_available_;
}
inline void Ems::set_is_engine_acc_available(bool value) {
  set_has_is_engine_acc_available();
  is_engine_acc_available_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.is_engine_acc_available)
}

// optional bool is_engine_acc_error = 2;
inline bool Ems::has_is_engine_acc_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ems::set_has_is_engine_acc_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ems::clear_has_is_engine_acc_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ems::clear_is_engine_acc_error() {
  is_engine_acc_error_ = false;
  clear_has_is_engine_acc_error();
}
inline bool Ems::is_engine_acc_error() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.is_engine_acc_error)
  return is_engine_acc_error_;
}
inline void Ems::set_is_engine_acc_error(bool value) {
  set_has_is_engine_acc_error();
  is_engine_acc_error_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.is_engine_acc_error)
}

// optional .apollo.canbus.Ems.Type engine_state = 3;
inline bool Ems::has_engine_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ems::set_has_engine_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ems::clear_has_engine_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ems::clear_engine_state() {
  engine_state_ = 0;
  clear_has_engine_state();
}
inline ::apollo::canbus::Ems_Type Ems::engine_state() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.engine_state)
  return static_cast< ::apollo::canbus::Ems_Type >(engine_state_);
}
inline void Ems::set_engine_state(::apollo::canbus::Ems_Type value) {
  assert(::apollo::canbus::Ems_Type_IsValid(value));
  set_has_engine_state();
  engine_state_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.engine_state)
}

// optional double max_engine_torq_percent = 4;
inline bool Ems::has_max_engine_torq_percent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ems::set_has_max_engine_torq_percent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ems::clear_has_max_engine_torq_percent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ems::clear_max_engine_torq_percent() {
  max_engine_torq_percent_ = 0;
  clear_has_max_engine_torq_percent();
}
inline double Ems::max_engine_torq_percent() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.max_engine_torq_percent)
  return max_engine_torq_percent_;
}
inline void Ems::set_max_engine_torq_percent(double value) {
  set_has_max_engine_torq_percent();
  max_engine_torq_percent_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.max_engine_torq_percent)
}

// optional double min_engine_torq_percent = 5;
inline bool Ems::has_min_engine_torq_percent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Ems::set_has_min_engine_torq_percent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Ems::clear_has_min_engine_torq_percent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Ems::clear_min_engine_torq_percent() {
  min_engine_torq_percent_ = 0;
  clear_has_min_engine_torq_percent();
}
inline double Ems::min_engine_torq_percent() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.min_engine_torq_percent)
  return min_engine_torq_percent_;
}
inline void Ems::set_min_engine_torq_percent(double value) {
  set_has_min_engine_torq_percent();
  min_engine_torq_percent_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.min_engine_torq_percent)
}

// optional int32 base_engine_torq_constant = 6;
inline bool Ems::has_base_engine_torq_constant() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Ems::set_has_base_engine_torq_constant() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Ems::clear_has_base_engine_torq_constant() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Ems::clear_base_engine_torq_constant() {
  base_engine_torq_constant_ = 0;
  clear_has_base_engine_torq_constant();
}
inline ::google::protobuf::int32 Ems::base_engine_torq_constant() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.base_engine_torq_constant)
  return base_engine_torq_constant_;
}
inline void Ems::set_base_engine_torq_constant(::google::protobuf::int32 value) {
  set_has_base_engine_torq_constant();
  base_engine_torq_constant_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.base_engine_torq_constant)
}

// optional bool is_engine_speed_error = 7;
inline bool Ems::has_is_engine_speed_error() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Ems::set_has_is_engine_speed_error() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Ems::clear_has_is_engine_speed_error() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Ems::clear_is_engine_speed_error() {
  is_engine_speed_error_ = false;
  clear_has_is_engine_speed_error();
}
inline bool Ems::is_engine_speed_error() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.is_engine_speed_error)
  return is_engine_speed_error_;
}
inline void Ems::set_is_engine_speed_error(bool value) {
  set_has_is_engine_speed_error();
  is_engine_speed_error_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.is_engine_speed_error)
}

// optional double engine_speed = 8;
inline bool Ems::has_engine_speed() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Ems::set_has_engine_speed() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Ems::clear_has_engine_speed() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Ems::clear_engine_speed() {
  engine_speed_ = 0;
  clear_has_engine_speed();
}
inline double Ems::engine_speed() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.engine_speed)
  return engine_speed_;
}
inline void Ems::set_engine_speed(double value) {
  set_has_engine_speed();
  engine_speed_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.engine_speed)
}

// optional int32 engine_torque = 9;
inline bool Ems::has_engine_torque() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Ems::set_has_engine_torque() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Ems::clear_has_engine_torque() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Ems::clear_engine_torque() {
  engine_torque_ = 0;
  clear_has_engine_torque();
}
inline ::google::protobuf::int32 Ems::engine_torque() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.engine_torque)
  return engine_torque_;
}
inline void Ems::set_engine_torque(::google::protobuf::int32 value) {
  set_has_engine_torque();
  engine_torque_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.engine_torque)
}

// optional bool is_over_engine_torque = 10;
inline bool Ems::has_is_over_engine_torque() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Ems::set_has_is_over_engine_torque() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Ems::clear_has_is_over_engine_torque() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Ems::clear_is_over_engine_torque() {
  is_over_engine_torque_ = false;
  clear_has_is_over_engine_torque();
}
inline bool Ems::is_over_engine_torque() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.is_over_engine_torque)
  return is_over_engine_torque_;
}
inline void Ems::set_is_over_engine_torque(bool value) {
  set_has_is_over_engine_torque();
  is_over_engine_torque_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.is_over_engine_torque)
}

// optional double engine_rpm = 11;
inline bool Ems::has_engine_rpm() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Ems::set_has_engine_rpm() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Ems::clear_has_engine_rpm() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Ems::clear_engine_rpm() {
  engine_rpm_ = 0;
  clear_has_engine_rpm();
}
inline double Ems::engine_rpm() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Ems.engine_rpm)
  return engine_rpm_;
}
inline void Ems::set_engine_rpm(double value) {
  set_has_engine_rpm();
  engine_rpm_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Ems.engine_rpm)
}

// -------------------------------------------------------------------

// Gear

// optional bool is_shift_position_valid = 1;
inline bool Gear::has_is_shift_position_valid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Gear::set_has_is_shift_position_valid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Gear::clear_has_is_shift_position_valid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Gear::clear_is_shift_position_valid() {
  is_shift_position_valid_ = false;
  clear_has_is_shift_position_valid();
}
inline bool Gear::is_shift_position_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gear.is_shift_position_valid)
  return is_shift_position_valid_;
}
inline void Gear::set_is_shift_position_valid(bool value) {
  set_has_is_shift_position_valid();
  is_shift_position_valid_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gear.is_shift_position_valid)
}

// optional .apollo.canbus.Chassis.GearPosition gear_state = 2;
inline bool Gear::has_gear_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Gear::set_has_gear_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Gear::clear_has_gear_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Gear::clear_gear_state() {
  gear_state_ = 0;
  clear_has_gear_state();
}
inline ::apollo::canbus::Chassis_GearPosition Gear::gear_state() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gear.gear_state)
  return static_cast< ::apollo::canbus::Chassis_GearPosition >(gear_state_);
}
inline void Gear::set_gear_state(::apollo::canbus::Chassis_GearPosition value) {
  assert(::apollo::canbus::Chassis_GearPosition_IsValid(value));
  set_has_gear_state();
  gear_state_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gear.gear_state)
}

// optional bool driver_override = 3;
inline bool Gear::has_driver_override() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Gear::set_has_driver_override() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Gear::clear_has_driver_override() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Gear::clear_driver_override() {
  driver_override_ = false;
  clear_has_driver_override();
}
inline bool Gear::driver_override() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gear.driver_override)
  return driver_override_;
}
inline void Gear::set_driver_override(bool value) {
  set_has_driver_override();
  driver_override_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gear.driver_override)
}

// optional .apollo.canbus.Chassis.GearPosition gear_cmd = 4;
inline bool Gear::has_gear_cmd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Gear::set_has_gear_cmd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Gear::clear_has_gear_cmd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Gear::clear_gear_cmd() {
  gear_cmd_ = 0;
  clear_has_gear_cmd();
}
inline ::apollo::canbus::Chassis_GearPosition Gear::gear_cmd() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gear.gear_cmd)
  return static_cast< ::apollo::canbus::Chassis_GearPosition >(gear_cmd_);
}
inline void Gear::set_gear_cmd(::apollo::canbus::Chassis_GearPosition value) {
  assert(::apollo::canbus::Chassis_GearPosition_IsValid(value));
  set_has_gear_cmd();
  gear_cmd_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gear.gear_cmd)
}

// optional bool canbus_fault = 5;
inline bool Gear::has_canbus_fault() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Gear::set_has_canbus_fault() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Gear::clear_has_canbus_fault() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Gear::clear_canbus_fault() {
  canbus_fault_ = false;
  clear_has_canbus_fault();
}
inline bool Gear::canbus_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gear.canbus_fault)
  return canbus_fault_;
}
inline void Gear::set_canbus_fault(bool value) {
  set_has_canbus_fault();
  canbus_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gear.canbus_fault)
}

// -------------------------------------------------------------------

// Safety

// optional bool is_driver_car_door_close = 1;
inline bool Safety::has_is_driver_car_door_close() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Safety::set_has_is_driver_car_door_close() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Safety::clear_has_is_driver_car_door_close() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Safety::clear_is_driver_car_door_close() {
  is_driver_car_door_close_ = false;
  clear_has_is_driver_car_door_close();
}
inline bool Safety::is_driver_car_door_close() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_driver_car_door_close)
  return is_driver_car_door_close_;
}
inline void Safety::set_is_driver_car_door_close(bool value) {
  set_has_is_driver_car_door_close();
  is_driver_car_door_close_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_driver_car_door_close)
}

// optional bool is_driver_buckled = 2;
inline bool Safety::has_is_driver_buckled() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Safety::set_has_is_driver_buckled() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Safety::clear_has_is_driver_buckled() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Safety::clear_is_driver_buckled() {
  is_driver_buckled_ = false;
  clear_has_is_driver_buckled();
}
inline bool Safety::is_driver_buckled() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_driver_buckled)
  return is_driver_buckled_;
}
inline void Safety::set_is_driver_buckled(bool value) {
  set_has_is_driver_buckled();
  is_driver_buckled_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_driver_buckled)
}

// optional int32 emergency_button = 3;
inline bool Safety::has_emergency_button() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Safety::set_has_emergency_button() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Safety::clear_has_emergency_button() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Safety::clear_emergency_button() {
  emergency_button_ = 0;
  clear_has_emergency_button();
}
inline ::google::protobuf::int32 Safety::emergency_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.emergency_button)
  return emergency_button_;
}
inline void Safety::set_emergency_button(::google::protobuf::int32 value) {
  set_has_emergency_button();
  emergency_button_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.emergency_button)
}

// optional bool has_error = 4 [default = false];
inline bool Safety::has_has_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Safety::set_has_has_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Safety::clear_has_has_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Safety::clear_has_error() {
  has_error_ = false;
  clear_has_has_error();
}
inline bool Safety::has_error() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.has_error)
  return has_error_;
}
inline void Safety::set_has_error(bool value) {
  set_has_has_error();
  has_error_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.has_error)
}

// optional bool is_motor_invertor_fault = 5;
inline bool Safety::has_is_motor_invertor_fault() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Safety::set_has_is_motor_invertor_fault() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Safety::clear_has_is_motor_invertor_fault() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Safety::clear_is_motor_invertor_fault() {
  is_motor_invertor_fault_ = false;
  clear_has_is_motor_invertor_fault();
}
inline bool Safety::is_motor_invertor_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_motor_invertor_fault)
  return is_motor_invertor_fault_;
}
inline void Safety::set_is_motor_invertor_fault(bool value) {
  set_has_is_motor_invertor_fault();
  is_motor_invertor_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_motor_invertor_fault)
}

// optional bool is_system_fault = 6;
inline bool Safety::has_is_system_fault() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Safety::set_has_is_system_fault() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Safety::clear_has_is_system_fault() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Safety::clear_is_system_fault() {
  is_system_fault_ = false;
  clear_has_is_system_fault();
}
inline bool Safety::is_system_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_system_fault)
  return is_system_fault_;
}
inline void Safety::set_is_system_fault(bool value) {
  set_has_is_system_fault();
  is_system_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_system_fault)
}

// optional bool is_power_battery_fault = 7;
inline bool Safety::has_is_power_battery_fault() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Safety::set_has_is_power_battery_fault() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Safety::clear_has_is_power_battery_fault() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Safety::clear_is_power_battery_fault() {
  is_power_battery_fault_ = false;
  clear_has_is_power_battery_fault();
}
inline bool Safety::is_power_battery_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_power_battery_fault)
  return is_power_battery_fault_;
}
inline void Safety::set_is_power_battery_fault(bool value) {
  set_has_is_power_battery_fault();
  is_power_battery_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_power_battery_fault)
}

// optional bool is_motor_invertor_over_temperature = 8;
inline bool Safety::has_is_motor_invertor_over_temperature() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Safety::set_has_is_motor_invertor_over_temperature() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Safety::clear_has_is_motor_invertor_over_temperature() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Safety::clear_is_motor_invertor_over_temperature() {
  is_motor_invertor_over_temperature_ = false;
  clear_has_is_motor_invertor_over_temperature();
}
inline bool Safety::is_motor_invertor_over_temperature() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_motor_invertor_over_temperature)
  return is_motor_invertor_over_temperature_;
}
inline void Safety::set_is_motor_invertor_over_temperature(bool value) {
  set_has_is_motor_invertor_over_temperature();
  is_motor_invertor_over_temperature_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_motor_invertor_over_temperature)
}

// optional bool is_small_battery_charge_discharge_fault = 9;
inline bool Safety::has_is_small_battery_charge_discharge_fault() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Safety::set_has_is_small_battery_charge_discharge_fault() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Safety::clear_has_is_small_battery_charge_discharge_fault() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Safety::clear_is_small_battery_charge_discharge_fault() {
  is_small_battery_charge_discharge_fault_ = false;
  clear_has_is_small_battery_charge_discharge_fault();
}
inline bool Safety::is_small_battery_charge_discharge_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_small_battery_charge_discharge_fault)
  return is_small_battery_charge_discharge_fault_;
}
inline void Safety::set_is_small_battery_charge_discharge_fault(bool value) {
  set_has_is_small_battery_charge_discharge_fault();
  is_small_battery_charge_discharge_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_small_battery_charge_discharge_fault)
}

// optional int32 driving_mode = 10;
inline bool Safety::has_driving_mode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Safety::set_has_driving_mode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Safety::clear_has_driving_mode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Safety::clear_driving_mode() {
  driving_mode_ = 0;
  clear_has_driving_mode();
}
inline ::google::protobuf::int32 Safety::driving_mode() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.driving_mode)
  return driving_mode_;
}
inline void Safety::set_driving_mode(::google::protobuf::int32 value) {
  set_has_driving_mode();
  driving_mode_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.driving_mode)
}

// optional bool is_passenger_door_open = 11;
inline bool Safety::has_is_passenger_door_open() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Safety::set_has_is_passenger_door_open() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Safety::clear_has_is_passenger_door_open() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Safety::clear_is_passenger_door_open() {
  is_passenger_door_open_ = false;
  clear_has_is_passenger_door_open();
}
inline bool Safety::is_passenger_door_open() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_passenger_door_open)
  return is_passenger_door_open_;
}
inline void Safety::set_is_passenger_door_open(bool value) {
  set_has_is_passenger_door_open();
  is_passenger_door_open_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_passenger_door_open)
}

// optional bool is_rearleft_door_open = 12;
inline bool Safety::has_is_rearleft_door_open() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Safety::set_has_is_rearleft_door_open() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Safety::clear_has_is_rearleft_door_open() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Safety::clear_is_rearleft_door_open() {
  is_rearleft_door_open_ = false;
  clear_has_is_rearleft_door_open();
}
inline bool Safety::is_rearleft_door_open() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_rearleft_door_open)
  return is_rearleft_door_open_;
}
inline void Safety::set_is_rearleft_door_open(bool value) {
  set_has_is_rearleft_door_open();
  is_rearleft_door_open_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_rearleft_door_open)
}

// optional bool is_rearright_door_open = 13;
inline bool Safety::has_is_rearright_door_open() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Safety::set_has_is_rearright_door_open() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Safety::clear_has_is_rearright_door_open() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Safety::clear_is_rearright_door_open() {
  is_rearright_door_open_ = false;
  clear_has_is_rearright_door_open();
}
inline bool Safety::is_rearright_door_open() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_rearright_door_open)
  return is_rearright_door_open_;
}
inline void Safety::set_is_rearright_door_open(bool value) {
  set_has_is_rearright_door_open();
  is_rearright_door_open_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_rearright_door_open)
}

// optional bool is_hood_open = 14;
inline bool Safety::has_is_hood_open() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Safety::set_has_is_hood_open() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Safety::clear_has_is_hood_open() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Safety::clear_is_hood_open() {
  is_hood_open_ = false;
  clear_has_is_hood_open();
}
inline bool Safety::is_hood_open() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_hood_open)
  return is_hood_open_;
}
inline void Safety::set_is_hood_open(bool value) {
  set_has_is_hood_open();
  is_hood_open_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_hood_open)
}

// optional bool is_trunk_open = 15;
inline bool Safety::has_is_trunk_open() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Safety::set_has_is_trunk_open() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Safety::clear_has_is_trunk_open() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Safety::clear_is_trunk_open() {
  is_trunk_open_ = false;
  clear_has_is_trunk_open();
}
inline bool Safety::is_trunk_open() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_trunk_open)
  return is_trunk_open_;
}
inline void Safety::set_is_trunk_open(bool value) {
  set_has_is_trunk_open();
  is_trunk_open_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_trunk_open)
}

// optional bool is_passenger_detected = 16;
inline bool Safety::has_is_passenger_detected() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Safety::set_has_is_passenger_detected() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Safety::clear_has_is_passenger_detected() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Safety::clear_is_passenger_detected() {
  is_passenger_detected_ = false;
  clear_has_is_passenger_detected();
}
inline bool Safety::is_passenger_detected() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_passenger_detected)
  return is_passenger_detected_;
}
inline void Safety::set_is_passenger_detected(bool value) {
  set_has_is_passenger_detected();
  is_passenger_detected_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_passenger_detected)
}

// optional bool is_passenger_airbag_enabled = 17;
inline bool Safety::has_is_passenger_airbag_enabled() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Safety::set_has_is_passenger_airbag_enabled() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Safety::clear_has_is_passenger_airbag_enabled() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Safety::clear_is_passenger_airbag_enabled() {
  is_passenger_airbag_enabled_ = false;
  clear_has_is_passenger_airbag_enabled();
}
inline bool Safety::is_passenger_airbag_enabled() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_passenger_airbag_enabled)
  return is_passenger_airbag_enabled_;
}
inline void Safety::set_is_passenger_airbag_enabled(bool value) {
  set_has_is_passenger_airbag_enabled();
  is_passenger_airbag_enabled_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_passenger_airbag_enabled)
}

// optional bool is_passenger_buckled = 18;
inline bool Safety::has_is_passenger_buckled() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Safety::set_has_is_passenger_buckled() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Safety::clear_has_is_passenger_buckled() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Safety::clear_is_passenger_buckled() {
  is_passenger_buckled_ = false;
  clear_has_is_passenger_buckled();
}
inline bool Safety::is_passenger_buckled() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.is_passenger_buckled)
  return is_passenger_buckled_;
}
inline void Safety::set_is_passenger_buckled(bool value) {
  set_has_is_passenger_buckled();
  is_passenger_buckled_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.is_passenger_buckled)
}

// optional int32 front_left_tire_press = 19;
inline bool Safety::has_front_left_tire_press() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Safety::set_has_front_left_tire_press() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Safety::clear_has_front_left_tire_press() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Safety::clear_front_left_tire_press() {
  front_left_tire_press_ = 0;
  clear_has_front_left_tire_press();
}
inline ::google::protobuf::int32 Safety::front_left_tire_press() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.front_left_tire_press)
  return front_left_tire_press_;
}
inline void Safety::set_front_left_tire_press(::google::protobuf::int32 value) {
  set_has_front_left_tire_press();
  front_left_tire_press_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.front_left_tire_press)
}

// optional int32 front_right_tire_press = 20;
inline bool Safety::has_front_right_tire_press() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Safety::set_has_front_right_tire_press() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Safety::clear_has_front_right_tire_press() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Safety::clear_front_right_tire_press() {
  front_right_tire_press_ = 0;
  clear_has_front_right_tire_press();
}
inline ::google::protobuf::int32 Safety::front_right_tire_press() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.front_right_tire_press)
  return front_right_tire_press_;
}
inline void Safety::set_front_right_tire_press(::google::protobuf::int32 value) {
  set_has_front_right_tire_press();
  front_right_tire_press_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.front_right_tire_press)
}

// optional int32 rear_left_tire_press = 21;
inline bool Safety::has_rear_left_tire_press() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Safety::set_has_rear_left_tire_press() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Safety::clear_has_rear_left_tire_press() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Safety::clear_rear_left_tire_press() {
  rear_left_tire_press_ = 0;
  clear_has_rear_left_tire_press();
}
inline ::google::protobuf::int32 Safety::rear_left_tire_press() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.rear_left_tire_press)
  return rear_left_tire_press_;
}
inline void Safety::set_rear_left_tire_press(::google::protobuf::int32 value) {
  set_has_rear_left_tire_press();
  rear_left_tire_press_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.rear_left_tire_press)
}

// optional int32 rear_right_tire_press = 22;
inline bool Safety::has_rear_right_tire_press() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Safety::set_has_rear_right_tire_press() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Safety::clear_has_rear_right_tire_press() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Safety::clear_rear_right_tire_press() {
  rear_right_tire_press_ = 0;
  clear_has_rear_right_tire_press();
}
inline ::google::protobuf::int32 Safety::rear_right_tire_press() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.rear_right_tire_press)
  return rear_right_tire_press_;
}
inline void Safety::set_rear_right_tire_press(::google::protobuf::int32 value) {
  set_has_rear_right_tire_press();
  rear_right_tire_press_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.rear_right_tire_press)
}

// optional .apollo.canbus.Chassis.DrivingMode car_driving_mode = 23;
inline bool Safety::has_car_driving_mode() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Safety::set_has_car_driving_mode() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Safety::clear_has_car_driving_mode() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Safety::clear_car_driving_mode() {
  car_driving_mode_ = 0;
  clear_has_car_driving_mode();
}
inline ::apollo::canbus::Chassis_DrivingMode Safety::car_driving_mode() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Safety.car_driving_mode)
  return static_cast< ::apollo::canbus::Chassis_DrivingMode >(car_driving_mode_);
}
inline void Safety::set_car_driving_mode(::apollo::canbus::Chassis_DrivingMode value) {
  assert(::apollo::canbus::Chassis_DrivingMode_IsValid(value));
  set_has_car_driving_mode();
  car_driving_mode_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Safety.car_driving_mode)
}

// -------------------------------------------------------------------

// BasicInfo

// optional bool is_auto_mode = 1;
inline bool BasicInfo::has_is_auto_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BasicInfo::set_has_is_auto_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BasicInfo::clear_has_is_auto_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BasicInfo::clear_is_auto_mode() {
  is_auto_mode_ = false;
  clear_has_is_auto_mode();
}
inline bool BasicInfo::is_auto_mode() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.is_auto_mode)
  return is_auto_mode_;
}
inline void BasicInfo::set_is_auto_mode(bool value) {
  set_has_is_auto_mode();
  is_auto_mode_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.is_auto_mode)
}

// optional .apollo.canbus.BasicInfo.Type power_state = 2;
inline bool BasicInfo::has_power_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BasicInfo::set_has_power_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BasicInfo::clear_has_power_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BasicInfo::clear_power_state() {
  power_state_ = 0;
  clear_has_power_state();
}
inline ::apollo::canbus::BasicInfo_Type BasicInfo::power_state() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.power_state)
  return static_cast< ::apollo::canbus::BasicInfo_Type >(power_state_);
}
inline void BasicInfo::set_power_state(::apollo::canbus::BasicInfo_Type value) {
  assert(::apollo::canbus::BasicInfo_Type_IsValid(value));
  set_has_power_state();
  power_state_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.power_state)
}

// optional bool is_air_bag_deployed = 3;
inline bool BasicInfo::has_is_air_bag_deployed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BasicInfo::set_has_is_air_bag_deployed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BasicInfo::clear_has_is_air_bag_deployed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BasicInfo::clear_is_air_bag_deployed() {
  is_air_bag_deployed_ = false;
  clear_has_is_air_bag_deployed();
}
inline bool BasicInfo::is_air_bag_deployed() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.is_air_bag_deployed)
  return is_air_bag_deployed_;
}
inline void BasicInfo::set_is_air_bag_deployed(bool value) {
  set_has_is_air_bag_deployed();
  is_air_bag_deployed_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.is_air_bag_deployed)
}

// optional double odo_meter = 4;
inline bool BasicInfo::has_odo_meter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BasicInfo::set_has_odo_meter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BasicInfo::clear_has_odo_meter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BasicInfo::clear_odo_meter() {
  odo_meter_ = 0;
  clear_has_odo_meter();
}
inline double BasicInfo::odo_meter() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.odo_meter)
  return odo_meter_;
}
inline void BasicInfo::set_odo_meter(double value) {
  set_has_odo_meter();
  odo_meter_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.odo_meter)
}

// optional double drive_range = 5;
inline bool BasicInfo::has_drive_range() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BasicInfo::set_has_drive_range() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BasicInfo::clear_has_drive_range() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BasicInfo::clear_drive_range() {
  drive_range_ = 0;
  clear_has_drive_range();
}
inline double BasicInfo::drive_range() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.drive_range)
  return drive_range_;
}
inline void BasicInfo::set_drive_range(double value) {
  set_has_drive_range();
  drive_range_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.drive_range)
}

// optional bool is_system_error = 6;
inline bool BasicInfo::has_is_system_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BasicInfo::set_has_is_system_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BasicInfo::clear_has_is_system_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BasicInfo::clear_is_system_error() {
  is_system_error_ = false;
  clear_has_is_system_error();
}
inline bool BasicInfo::is_system_error() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.is_system_error)
  return is_system_error_;
}
inline void BasicInfo::set_is_system_error(bool value) {
  set_has_is_system_error();
  is_system_error_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.is_system_error)
}

// optional bool is_human_interrupt = 7;
inline bool BasicInfo::has_is_human_interrupt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BasicInfo::set_has_is_human_interrupt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BasicInfo::clear_has_is_human_interrupt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BasicInfo::clear_is_human_interrupt() {
  is_human_interrupt_ = false;
  clear_has_is_human_interrupt();
}
inline bool BasicInfo::is_human_interrupt() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.is_human_interrupt)
  return is_human_interrupt_;
}
inline void BasicInfo::set_is_human_interrupt(bool value) {
  set_has_is_human_interrupt();
  is_human_interrupt_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.is_human_interrupt)
}

// optional bool acc_on_button = 8;
inline bool BasicInfo::has_acc_on_button() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BasicInfo::set_has_acc_on_button() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BasicInfo::clear_has_acc_on_button() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BasicInfo::clear_acc_on_button() {
  acc_on_button_ = false;
  clear_has_acc_on_button();
}
inline bool BasicInfo::acc_on_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_on_button)
  return acc_on_button_;
}
inline void BasicInfo::set_acc_on_button(bool value) {
  set_has_acc_on_button();
  acc_on_button_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_on_button)
}

// optional bool acc_off_button = 9;
inline bool BasicInfo::has_acc_off_button() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BasicInfo::set_has_acc_off_button() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BasicInfo::clear_has_acc_off_button() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BasicInfo::clear_acc_off_button() {
  acc_off_button_ = false;
  clear_has_acc_off_button();
}
inline bool BasicInfo::acc_off_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_off_button)
  return acc_off_button_;
}
inline void BasicInfo::set_acc_off_button(bool value) {
  set_has_acc_off_button();
  acc_off_button_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_off_button)
}

// optional bool acc_res_button = 10;
inline bool BasicInfo::has_acc_res_button() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BasicInfo::set_has_acc_res_button() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BasicInfo::clear_has_acc_res_button() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BasicInfo::clear_acc_res_button() {
  acc_res_button_ = false;
  clear_has_acc_res_button();
}
inline bool BasicInfo::acc_res_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_res_button)
  return acc_res_button_;
}
inline void BasicInfo::set_acc_res_button(bool value) {
  set_has_acc_res_button();
  acc_res_button_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_res_button)
}

// optional bool acc_cancel_button = 11;
inline bool BasicInfo::has_acc_cancel_button() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BasicInfo::set_has_acc_cancel_button() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BasicInfo::clear_has_acc_cancel_button() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BasicInfo::clear_acc_cancel_button() {
  acc_cancel_button_ = false;
  clear_has_acc_cancel_button();
}
inline bool BasicInfo::acc_cancel_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_cancel_button)
  return acc_cancel_button_;
}
inline void BasicInfo::set_acc_cancel_button(bool value) {
  set_has_acc_cancel_button();
  acc_cancel_button_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_cancel_button)
}

// optional bool acc_on_off_button = 12;
inline bool BasicInfo::has_acc_on_off_button() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BasicInfo::set_has_acc_on_off_button() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BasicInfo::clear_has_acc_on_off_button() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BasicInfo::clear_acc_on_off_button() {
  acc_on_off_button_ = false;
  clear_has_acc_on_off_button();
}
inline bool BasicInfo::acc_on_off_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_on_off_button)
  return acc_on_off_button_;
}
inline void BasicInfo::set_acc_on_off_button(bool value) {
  set_has_acc_on_off_button();
  acc_on_off_button_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_on_off_button)
}

// optional bool acc_res_cancel_button = 13;
inline bool BasicInfo::has_acc_res_cancel_button() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BasicInfo::set_has_acc_res_cancel_button() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BasicInfo::clear_has_acc_res_cancel_button() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BasicInfo::clear_acc_res_cancel_button() {
  acc_res_cancel_button_ = false;
  clear_has_acc_res_cancel_button();
}
inline bool BasicInfo::acc_res_cancel_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_res_cancel_button)
  return acc_res_cancel_button_;
}
inline void BasicInfo::set_acc_res_cancel_button(bool value) {
  set_has_acc_res_cancel_button();
  acc_res_cancel_button_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_res_cancel_button)
}

// optional bool acc_inc_spd_button = 14;
inline bool BasicInfo::has_acc_inc_spd_button() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BasicInfo::set_has_acc_inc_spd_button() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BasicInfo::clear_has_acc_inc_spd_button() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BasicInfo::clear_acc_inc_spd_button() {
  acc_inc_spd_button_ = false;
  clear_has_acc_inc_spd_button();
}
inline bool BasicInfo::acc_inc_spd_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_inc_spd_button)
  return acc_inc_spd_button_;
}
inline void BasicInfo::set_acc_inc_spd_button(bool value) {
  set_has_acc_inc_spd_button();
  acc_inc_spd_button_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_inc_spd_button)
}

// optional bool acc_dec_spd_button = 15;
inline bool BasicInfo::has_acc_dec_spd_button() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BasicInfo::set_has_acc_dec_spd_button() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BasicInfo::clear_has_acc_dec_spd_button() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BasicInfo::clear_acc_dec_spd_button() {
  acc_dec_spd_button_ = false;
  clear_has_acc_dec_spd_button();
}
inline bool BasicInfo::acc_dec_spd_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_dec_spd_button)
  return acc_dec_spd_button_;
}
inline void BasicInfo::set_acc_dec_spd_button(bool value) {
  set_has_acc_dec_spd_button();
  acc_dec_spd_button_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_dec_spd_button)
}

// optional bool acc_inc_gap_button = 16;
inline bool BasicInfo::has_acc_inc_gap_button() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BasicInfo::set_has_acc_inc_gap_button() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BasicInfo::clear_has_acc_inc_gap_button() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BasicInfo::clear_acc_inc_gap_button() {
  acc_inc_gap_button_ = false;
  clear_has_acc_inc_gap_button();
}
inline bool BasicInfo::acc_inc_gap_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_inc_gap_button)
  return acc_inc_gap_button_;
}
inline void BasicInfo::set_acc_inc_gap_button(bool value) {
  set_has_acc_inc_gap_button();
  acc_inc_gap_button_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_inc_gap_button)
}

// optional bool acc_dec_gap_button = 17;
inline bool BasicInfo::has_acc_dec_gap_button() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BasicInfo::set_has_acc_dec_gap_button() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BasicInfo::clear_has_acc_dec_gap_button() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BasicInfo::clear_acc_dec_gap_button() {
  acc_dec_gap_button_ = false;
  clear_has_acc_dec_gap_button();
}
inline bool BasicInfo::acc_dec_gap_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.acc_dec_gap_button)
  return acc_dec_gap_button_;
}
inline void BasicInfo::set_acc_dec_gap_button(bool value) {
  set_has_acc_dec_gap_button();
  acc_dec_gap_button_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.acc_dec_gap_button)
}

// optional bool lka_button = 18;
inline bool BasicInfo::has_lka_button() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void BasicInfo::set_has_lka_button() {
  _has_bits_[0] |= 0x00020000u;
}
inline void BasicInfo::clear_has_lka_button() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void BasicInfo::clear_lka_button() {
  lka_button_ = false;
  clear_has_lka_button();
}
inline bool BasicInfo::lka_button() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.lka_button)
  return lka_button_;
}
inline void BasicInfo::set_lka_button(bool value) {
  set_has_lka_button();
  lka_button_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.lka_button)
}

// optional bool canbus_fault = 19;
inline bool BasicInfo::has_canbus_fault() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void BasicInfo::set_has_canbus_fault() {
  _has_bits_[0] |= 0x00040000u;
}
inline void BasicInfo::clear_has_canbus_fault() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void BasicInfo::clear_canbus_fault() {
  canbus_fault_ = false;
  clear_has_canbus_fault();
}
inline bool BasicInfo::canbus_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.canbus_fault)
  return canbus_fault_;
}
inline void BasicInfo::set_canbus_fault(bool value) {
  set_has_canbus_fault();
  canbus_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.canbus_fault)
}

// optional double latitude = 20;
inline bool BasicInfo::has_latitude() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void BasicInfo::set_has_latitude() {
  _has_bits_[0] |= 0x00100000u;
}
inline void BasicInfo::clear_has_latitude() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void BasicInfo::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double BasicInfo::latitude() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.latitude)
  return latitude_;
}
inline void BasicInfo::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.latitude)
}

// optional double longitude = 21;
inline bool BasicInfo::has_longitude() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void BasicInfo::set_has_longitude() {
  _has_bits_[0] |= 0x00200000u;
}
inline void BasicInfo::clear_has_longitude() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void BasicInfo::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double BasicInfo::longitude() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.longitude)
  return longitude_;
}
inline void BasicInfo::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.longitude)
}

// optional bool gps_valid = 22;
inline bool BasicInfo::has_gps_valid() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void BasicInfo::set_has_gps_valid() {
  _has_bits_[0] |= 0x08000000u;
}
inline void BasicInfo::clear_has_gps_valid() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void BasicInfo::clear_gps_valid() {
  gps_valid_ = false;
  clear_has_gps_valid();
}
inline bool BasicInfo::gps_valid() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.gps_valid)
  return gps_valid_;
}
inline void BasicInfo::set_gps_valid(bool value) {
  set_has_gps_valid();
  gps_valid_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.gps_valid)
}

// optional int32 year = 23;
inline bool BasicInfo::has_year() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void BasicInfo::set_has_year() {
  _has_bits_[0] |= 0x00080000u;
}
inline void BasicInfo::clear_has_year() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void BasicInfo::clear_year() {
  year_ = 0;
  clear_has_year();
}
inline ::google::protobuf::int32 BasicInfo::year() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.year)
  return year_;
}
inline void BasicInfo::set_year(::google::protobuf::int32 value) {
  set_has_year();
  year_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.year)
}

// optional int32 month = 24;
inline bool BasicInfo::has_month() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void BasicInfo::set_has_month() {
  _has_bits_[0] |= 0x00400000u;
}
inline void BasicInfo::clear_has_month() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void BasicInfo::clear_month() {
  month_ = 0;
  clear_has_month();
}
inline ::google::protobuf::int32 BasicInfo::month() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.month)
  return month_;
}
inline void BasicInfo::set_month(::google::protobuf::int32 value) {
  set_has_month();
  month_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.month)
}

// optional int32 day = 25;
inline bool BasicInfo::has_day() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void BasicInfo::set_has_day() {
  _has_bits_[0] |= 0x00800000u;
}
inline void BasicInfo::clear_has_day() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void BasicInfo::clear_day() {
  day_ = 0;
  clear_has_day();
}
inline ::google::protobuf::int32 BasicInfo::day() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.day)
  return day_;
}
inline void BasicInfo::set_day(::google::protobuf::int32 value) {
  set_has_day();
  day_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.day)
}

// optional int32 hours = 26;
inline bool BasicInfo::has_hours() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void BasicInfo::set_has_hours() {
  _has_bits_[0] |= 0x01000000u;
}
inline void BasicInfo::clear_has_hours() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void BasicInfo::clear_hours() {
  hours_ = 0;
  clear_has_hours();
}
inline ::google::protobuf::int32 BasicInfo::hours() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.hours)
  return hours_;
}
inline void BasicInfo::set_hours(::google::protobuf::int32 value) {
  set_has_hours();
  hours_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.hours)
}

// optional int32 minutes = 27;
inline bool BasicInfo::has_minutes() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void BasicInfo::set_has_minutes() {
  _has_bits_[0] |= 0x02000000u;
}
inline void BasicInfo::clear_has_minutes() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void BasicInfo::clear_minutes() {
  minutes_ = 0;
  clear_has_minutes();
}
inline ::google::protobuf::int32 BasicInfo::minutes() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.minutes)
  return minutes_;
}
inline void BasicInfo::set_minutes(::google::protobuf::int32 value) {
  set_has_minutes();
  minutes_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.minutes)
}

// optional int32 seconds = 28;
inline bool BasicInfo::has_seconds() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void BasicInfo::set_has_seconds() {
  _has_bits_[0] |= 0x04000000u;
}
inline void BasicInfo::clear_has_seconds() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void BasicInfo::clear_seconds() {
  seconds_ = 0;
  clear_has_seconds();
}
inline ::google::protobuf::int32 BasicInfo::seconds() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.seconds)
  return seconds_;
}
inline void BasicInfo::set_seconds(::google::protobuf::int32 value) {
  set_has_seconds();
  seconds_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.seconds)
}

// optional double compass_direction = 29;
inline bool BasicInfo::has_compass_direction() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void BasicInfo::set_has_compass_direction() {
  _has_bits_[0] |= 0x40000000u;
}
inline void BasicInfo::clear_has_compass_direction() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void BasicInfo::clear_compass_direction() {
  compass_direction_ = 0;
  clear_has_compass_direction();
}
inline double BasicInfo::compass_direction() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.compass_direction)
  return compass_direction_;
}
inline void BasicInfo::set_compass_direction(double value) {
  set_has_compass_direction();
  compass_direction_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.compass_direction)
}

// optional double pdop = 30;
inline bool BasicInfo::has_pdop() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void BasicInfo::set_has_pdop() {
  _has_bits_[0] |= 0x80000000u;
}
inline void BasicInfo::clear_has_pdop() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void BasicInfo::clear_pdop() {
  pdop_ = 0;
  clear_has_pdop();
}
inline double BasicInfo::pdop() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.pdop)
  return pdop_;
}
inline void BasicInfo::set_pdop(double value) {
  set_has_pdop();
  pdop_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.pdop)
}

// optional bool is_gps_fault = 31;
inline bool BasicInfo::has_is_gps_fault() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void BasicInfo::set_has_is_gps_fault() {
  _has_bits_[0] |= 0x10000000u;
}
inline void BasicInfo::clear_has_is_gps_fault() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void BasicInfo::clear_is_gps_fault() {
  is_gps_fault_ = false;
  clear_has_is_gps_fault();
}
inline bool BasicInfo::is_gps_fault() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.is_gps_fault)
  return is_gps_fault_;
}
inline void BasicInfo::set_is_gps_fault(bool value) {
  set_has_is_gps_fault();
  is_gps_fault_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.is_gps_fault)
}

// optional bool is_inferred = 32;
inline bool BasicInfo::has_is_inferred() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void BasicInfo::set_has_is_inferred() {
  _has_bits_[0] |= 0x20000000u;
}
inline void BasicInfo::clear_has_is_inferred() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void BasicInfo::clear_is_inferred() {
  is_inferred_ = false;
  clear_has_is_inferred();
}
inline bool BasicInfo::is_inferred() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.is_inferred)
  return is_inferred_;
}
inline void BasicInfo::set_is_inferred(bool value) {
  set_has_is_inferred();
  is_inferred_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.is_inferred)
}

// optional double altitude = 33;
inline bool BasicInfo::has_altitude() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void BasicInfo::set_has_altitude() {
  _has_bits_[1] |= 0x00000001u;
}
inline void BasicInfo::clear_has_altitude() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void BasicInfo::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline double BasicInfo::altitude() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.altitude)
  return altitude_;
}
inline void BasicInfo::set_altitude(double value) {
  set_has_altitude();
  altitude_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.altitude)
}

// optional double heading = 34;
inline bool BasicInfo::has_heading() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void BasicInfo::set_has_heading() {
  _has_bits_[1] |= 0x00000002u;
}
inline void BasicInfo::clear_has_heading() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void BasicInfo::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline double BasicInfo::heading() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.heading)
  return heading_;
}
inline void BasicInfo::set_heading(double value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.heading)
}

// optional double hdop = 35;
inline bool BasicInfo::has_hdop() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void BasicInfo::set_has_hdop() {
  _has_bits_[1] |= 0x00000004u;
}
inline void BasicInfo::clear_has_hdop() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void BasicInfo::clear_hdop() {
  hdop_ = 0;
  clear_has_hdop();
}
inline double BasicInfo::hdop() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.hdop)
  return hdop_;
}
inline void BasicInfo::set_hdop(double value) {
  set_has_hdop();
  hdop_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.hdop)
}

// optional double vdop = 36;
inline bool BasicInfo::has_vdop() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void BasicInfo::set_has_vdop() {
  _has_bits_[1] |= 0x00000008u;
}
inline void BasicInfo::clear_has_vdop() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void BasicInfo::clear_vdop() {
  vdop_ = 0;
  clear_has_vdop();
}
inline double BasicInfo::vdop() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.vdop)
  return vdop_;
}
inline void BasicInfo::set_vdop(double value) {
  set_has_vdop();
  vdop_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.vdop)
}

// optional .apollo.canbus.GpsQuality quality = 37;
inline bool BasicInfo::has_quality() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void BasicInfo::set_has_quality() {
  _has_bits_[1] |= 0x00000010u;
}
inline void BasicInfo::clear_has_quality() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void BasicInfo::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline ::apollo::canbus::GpsQuality BasicInfo::quality() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.quality)
  return static_cast< ::apollo::canbus::GpsQuality >(quality_);
}
inline void BasicInfo::set_quality(::apollo::canbus::GpsQuality value) {
  assert(::apollo::canbus::GpsQuality_IsValid(value));
  set_has_quality();
  quality_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.quality)
}

// optional int32 num_satellites = 38;
inline bool BasicInfo::has_num_satellites() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void BasicInfo::set_has_num_satellites() {
  _has_bits_[1] |= 0x00000020u;
}
inline void BasicInfo::clear_has_num_satellites() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void BasicInfo::clear_num_satellites() {
  num_satellites_ = 0;
  clear_has_num_satellites();
}
inline ::google::protobuf::int32 BasicInfo::num_satellites() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.num_satellites)
  return num_satellites_;
}
inline void BasicInfo::set_num_satellites(::google::protobuf::int32 value) {
  set_has_num_satellites();
  num_satellites_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.num_satellites)
}

// optional double gps_speed = 39;
inline bool BasicInfo::has_gps_speed() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void BasicInfo::set_has_gps_speed() {
  _has_bits_[1] |= 0x00000040u;
}
inline void BasicInfo::clear_has_gps_speed() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void BasicInfo::clear_gps_speed() {
  gps_speed_ = 0;
  clear_has_gps_speed();
}
inline double BasicInfo::gps_speed() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.BasicInfo.gps_speed)
  return gps_speed_;
}
inline void BasicInfo::set_gps_speed(double value) {
  set_has_gps_speed();
  gps_speed_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.BasicInfo.gps_speed)
}

// -------------------------------------------------------------------

// License

// optional string vin = 1;
inline bool License::has_vin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void License::set_has_vin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void License::clear_has_vin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void License::clear_vin() {
  vin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vin();
}
inline const ::std::string& License::vin() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.License.vin)
  return vin_.GetNoArena();
}
inline void License::set_vin(const ::std::string& value) {
  set_has_vin();
  vin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.canbus.License.vin)
}
#if LANG_CXX11
inline void License::set_vin(::std::string&& value) {
  set_has_vin();
  vin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.canbus.License.vin)
}
#endif
inline void License::set_vin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_vin();
  vin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.canbus.License.vin)
}
inline void License::set_vin(const char* value, size_t size) {
  set_has_vin();
  vin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.canbus.License.vin)
}
inline ::std::string* License::mutable_vin() {
  set_has_vin();
  // @@protoc_insertion_point(field_mutable:apollo.canbus.License.vin)
  return vin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* License::release_vin() {
  // @@protoc_insertion_point(field_release:apollo.canbus.License.vin)
  clear_has_vin();
  return vin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void License::set_allocated_vin(::std::string* vin) {
  if (vin != NULL) {
    set_has_vin();
  } else {
    clear_has_vin();
  }
  vin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vin);
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.License.vin)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace canbus
}  // namespace apollo

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::apollo::canbus::ChassisDetail_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::ChassisDetail_Type>() {
  return ::apollo::canbus::ChassisDetail_Type_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Light_TurnLightType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Light_TurnLightType>() {
  return ::apollo::canbus::Light_TurnLightType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Light_LampType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Light_LampType>() {
  return ::apollo::canbus::Light_LampType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Light_LincolnLampType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Light_LincolnLampType>() {
  return ::apollo::canbus::Light_LincolnLampType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Light_LincolnWiperType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Light_LincolnWiperType>() {
  return ::apollo::canbus::Light_LincolnWiperType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Light_LincolnAmbientType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Light_LincolnAmbientType>() {
  return ::apollo::canbus::Light_LincolnAmbientType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Eps_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Eps_Type>() {
  return ::apollo::canbus::Eps_Type_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::VehicleSpd_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::VehicleSpd_Type>() {
  return ::apollo::canbus::VehicleSpd_Type_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Brake_HSAStatusType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Brake_HSAStatusType>() {
  return ::apollo::canbus::Brake_HSAStatusType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Brake_HSAModeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Brake_HSAModeType>() {
  return ::apollo::canbus::Brake_HSAModeType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Epb_PBrakeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Epb_PBrakeType>() {
  return ::apollo::canbus::Epb_PBrakeType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Ems_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Ems_Type>() {
  return ::apollo::canbus::Ems_Type_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::BasicInfo_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::BasicInfo_Type>() {
  return ::apollo::canbus::BasicInfo_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto__INCLUDED
